<?xml version="1.0" encoding="UTF-8"?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
  <channel>
    <title>Avalon</title>
    <description>抱朴 守拙
</description>
    <link>https://techctu.github.io//</link>
    <atom:link href="https://techctu.github.io//feed.xml" rel="self" type="application/rss+xml" />
    <pubDate>Sat, 04 Feb 2017 20:29:24 +0800</pubDate>
    <lastBuildDate>Sat, 04 Feb 2017 20:29:24 +0800</lastBuildDate>
    <generator>Jekyll v3.1.6</generator>
    
      <item>
        <title>停止更新，使用issues来记录</title>
        <description>&lt;p&gt;最后一篇，以后使用 &lt;a href=&quot;https://github.com/techctu/techctu.github.io/issues&quot;&gt;issues&lt;/a&gt; 来记录。&lt;/p&gt;

&lt;p&gt;有空了再挑挑文章来迁移。&lt;/p&gt;
</description>
        <pubDate>Sat, 04 Feb 2017 00:00:00 +0800</pubDate>
        <link>https://techctu.github.io//2017/02/04/%E5%81%9C%E6%AD%A2%E6%9B%B4%E6%96%B0%E4%BD%BF%E7%94%A8issues%E6%9D%A5%E8%AE%B0%E5%BD%95.html</link>
        <guid isPermaLink="true">https://techctu.github.io//2017/02/04/%E5%81%9C%E6%AD%A2%E6%9B%B4%E6%96%B0%E4%BD%BF%E7%94%A8issues%E6%9D%A5%E8%AE%B0%E5%BD%95.html</guid>
        
        
      </item>
    
      <item>
        <title>使用GSAP简单实现react列表中的下拉刷新和上拉加载更多</title>
        <description>&lt;p&gt;项目上线后看着列表不能下拉刷新不能上拉加载非常不爽，就做了个简单的实现。&lt;/p&gt;

&lt;p&gt;&lt;em&gt;为什么自己造轮子？用react不想添加jQuery，同时GitHub上的大部分代码都不能同时支持上拉和下拉。&lt;/em&gt;&lt;/p&gt;

&lt;h1 id=&quot;section&quot;&gt;准备&lt;/h1&gt;
&lt;p&gt;找个现成的项目新建一个页面，写个timeout模拟异步请求。&lt;/p&gt;

&lt;pre&gt;&lt;code class=&quot;language-js&quot;&gt;refresh() {
  setTimeout(()=&amp;gt;{this.setState({
    items: [1,2,3,4,5]
  })}, 1000);
}

loadMore() {
  setTimeout(()=&amp;gt;{this.setState({
    items: this.state.items.concat([1,2,3,4,5])
  })}, 1000);
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;再整个生成列表。&lt;/p&gt;

&lt;pre&gt;&lt;code class=&quot;language-js&quot;&gt;function renderList(list) {
  return (list.map((v, i) =&amp;gt; (
    &amp;lt;li key={i} onClick={function() {browserHistory.push(&#39;/MerchantDetail/&#39; + v.id + &#39;/&#39; + v.distance);}}&amp;gt;
      &amp;lt;div styleName=&quot;m-shop-right&quot;&amp;gt;
        &amp;lt;h1&amp;gt;
          {i}
        &amp;lt;/h1&amp;gt;
      &amp;lt;/div&amp;gt;
    &amp;lt;/li&amp;gt;)
    )
  );
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;然后开始搞事情。&lt;/p&gt;

&lt;h1 id=&quot;section-1&quot;&gt;实现下拉和上拉&lt;/h1&gt;

&lt;h2 id=&quot;section-2&quot;&gt;设计&lt;/h2&gt;
&lt;p&gt;现在的上拉和下拉大部分是：&lt;/p&gt;

&lt;ol&gt;
  &lt;li&gt;监听ontouchstart, ontouchmove, ontouchend三个事件。&lt;/li&gt;
  &lt;li&gt;判断上拉下拉边界，进行对应的CSS transform和transition。&lt;/li&gt;
&lt;/ol&gt;

&lt;pre&gt;&lt;code class=&quot;language-js&quot;&gt;// sample，监听list的事件，修改list-header
&amp;lt;div id=&quot;list&quot;&amp;gt;
    &amp;lt;div id=&quot;list-header&quot; /&amp;gt;
    &amp;lt;div id=&quot;list-items&quot; /&amp;gt;
&amp;lt;/div&amp;gt;
&lt;/code&gt;&lt;/pre&gt;

&lt;h2 id=&quot;section-3&quot;&gt;实现&lt;/h2&gt;
&lt;p&gt;最开始想用 &lt;code&gt;react-css-transition-group&lt;/code&gt; 或 &lt;code&gt;react-transition-group&lt;/code&gt; 来实现上拉和下拉效果，像这样：&lt;/p&gt;

&lt;pre&gt;&lt;code class=&quot;language-js&quot;&gt;&amp;lt;reactcsstransitiongroup ref={(el) =&amp;gt; this._ref = el}&amp;gt;
    &amp;lt;div id=&quot;list-header&quot; /&amp;gt;
    &amp;lt;div id=&quot;list-items&quot; /&amp;gt;
&amp;lt;/reactcsstransitiongroup&amp;gt;
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;然而仔细阅读了之后，发现只能在 &lt;code&gt;mount&lt;/code&gt; 和 &lt;code&gt;unmount&lt;/code&gt; 这两个关键点触发动画，在 &lt;code&gt;update&lt;/code&gt; 的时候无法触发。&lt;/p&gt;

&lt;p&gt;我非常不希望通过 &lt;code&gt;&amp;lt;div style=/&amp;gt;&lt;/code&gt; 的方式，每次滑动的时候就render一次。于是去找GitHub提了issue，和大佬对话的&lt;a href=&quot;https://github.com/reactjs/react-transition-group/issues/8&quot;&gt;传送门&lt;/a&gt;，大意就是说现在没法直接获得list-header的ref，得 &lt;code&gt;findDOMNode(this._ref).children[0]&lt;/code&gt;。&lt;/p&gt;

&lt;p&gt;这个就非常微妙了，既然如此，我为何一定要用 &lt;code&gt;react-css-transition-group&lt;/code&gt; 或 &lt;code&gt;react-transition-group&lt;/code&gt; 呢？简单点不好么？直接把这部分动画操作放在直接的DOM操作里绕开react，然后在ontouchend里回调，也是一种不错的思路。&lt;/p&gt;

&lt;pre&gt;&lt;code class=&quot;language-js&quot;&gt;&amp;lt;div id=&quot;g-wrap&quot; onTouchStart={(e) =&amp;gt; this.handleTouchStart(e)} 
  onTouchMove={(e) =&amp;gt; this.handleTouchMove(e)} 
  onTouchEnd={(e) =&amp;gt; this.handleTouchEnd(e)}&amp;gt; 
    // ...
&amp;lt;/div&amp;gt;
&lt;/code&gt;&lt;/pre&gt;

&lt;pre&gt;&lt;code class=&quot;language-js&quot;&gt;handleTouchStart(e) {
  this._touchStartPosY = e.touches[0].pageY;//记录触摸开始位置
  this._gmainDefaultPaddingTopRem = &#39;1.8rem&#39;;//记录初始列表头部位置，可改成接收参数
  this._gmainDefaultPaddingTop = parseInt(
    this._gmainDefaultPaddingTopRem.substr(0, this._gmainDefaultPaddingTopRem.length - 3));
  this._gmainDefaultPaddingBottom = 0;//底部
  this._lastScrollY = -1;//用于记录上一次滚动位置
  this._equalScroll = false;//用于标记上拉到了底部
}

handleTouchMove(e) {
  this._touchEndPosY = e.touches[0].pageY;

  // 下拉到顶
  if (window.scrollY &amp;lt;= 0) {
    this._lastScrollY = window.scrollY;
    // 拉且限制拉的距离
    if (this._touchEndPosY - this._touchStartPosY &amp;gt; 0 &amp;amp;&amp;amp; this._touchEndPosY - this._touchStartPosY &amp;lt; 100) {
      let gmain = findDOMNode(this._gmain);
      // 偷懒使用TweenMax来生成动画
      TweenMax.to(gmain, 0, 
        {paddingTop: this._gmainDefaultPaddingTop + 
            (this._touchEndPosY - this._touchStartPosY)/20 + &#39;rem&#39;, 
            ease: Power0.easeInOut});
    }
  } else {
    // 上拉到底
    if (window.scrollY == this._lastScrollY) {
      if (!this._equalScroll) {
        this._equalScroll = true;
        this._equalScrollY = window.scrollY;
        this._equalClientY = e.touches[0].clientY;
      } 
      let gmain = findDOMNode(this._gmain);
      e.preventDefault();
      // 限制上拉距离生成动画
      let offsetY = this._touchEndPosY&amp;gt;100?100:this._touchEndPosY;
      TweenMax.to(gmain, 0, 
        {paddingBottom: this._gmainDefaultPaddingBottom + offsetY/20&amp;gt; + &#39;rem&#39;, 
        ease: Power0.easeInOut});
      
    } else {
      this._lastScrollY = window.scrollY;
    }
  }
}

handleTouchEnd(e) {
  if (window.scrollY &amp;lt;= 0) {
    if (this._touchEndPosY - this._touchStartPosY &amp;gt; 0) {
      let gmain = findDOMNode(this._gmain);
      // 弹回
      TweenMax.to(gmain, 1, 
        {paddingTop: this._gmainDefaultPaddingTopRem, 
            ease: Back.easeInOut});
      this.refresh();
    }
  } else {
    if (this._equalScroll) {
      let gmain = findDOMNode(this._gmain);
      // 弹回
      TweenMax.to(gmain, 1, 
        {paddingBottom: this._gmainDefaultPaddingBottom, 
            ease: Power3.easeInOut});
      this.loadMore();
    }
  }
}
&lt;/code&gt;&lt;/pre&gt;

&lt;h1 id=&quot;section-4&quot;&gt;总结&lt;/h1&gt;
&lt;p&gt;整个思路就是：通过起始 &lt;code&gt;pageY&lt;/code&gt; 和结束 &lt;code&gt;pageY&lt;/code&gt; 判断用户垂直滑动方向，在根据 &lt;code&gt;window.scrollY&lt;/code&gt; 和保存的上一次滑动位置来判断是否到顶（或者到底），到顶（或者到底）后执行 tansform，touchEnd的时候进行回调。&lt;/p&gt;

&lt;p&gt;当然这只是个简单实践，还需要进一步优化，比如：&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;支持传入回调函数。&lt;/li&gt;
  &lt;li&gt;支持定义限制的上拉下拉高度。&lt;/li&gt;
  &lt;li&gt;支持上拉下拉时载入自定义的静态资源，如活动动画或是刷新效果等。&lt;/li&gt;
  &lt;li&gt;设置默认参数。&lt;/li&gt;
  &lt;li&gt;将TweenMax改为原生方法实现减少大小。&lt;/li&gt;
  &lt;li&gt;抽取为high-order-component。&lt;/li&gt;
  &lt;li&gt;最近这种纯前端的东西做的有点多，是时候拿 nodejs 和 express/koa 搞事情了。&lt;/li&gt;
&lt;/ul&gt;
</description>
        <pubDate>Wed, 11 Jan 2017 00:00:00 +0800</pubDate>
        <link>https://techctu.github.io//2017/01/11/%E4%BD%BF%E7%94%A8gsap%E7%AE%80%E5%8D%95%E5%AE%9E%E7%8E%B0react%E5%88%97%E8%A1%A8%E4%B8%AD%E7%9A%84%E4%B8%8B%E6%8B%89%E5%88%B7%E6%96%B0%E5%92%8C%E4%B8%8A%E6%8B%89%E5%8A%A0%E8%BD%BD%E6%9B%B4%E5%A4%9A.html</link>
        <guid isPermaLink="true">https://techctu.github.io//2017/01/11/%E4%BD%BF%E7%94%A8gsap%E7%AE%80%E5%8D%95%E5%AE%9E%E7%8E%B0react%E5%88%97%E8%A1%A8%E4%B8%AD%E7%9A%84%E4%B8%8B%E6%8B%89%E5%88%B7%E6%96%B0%E5%92%8C%E4%B8%8A%E6%8B%89%E5%8A%A0%E8%BD%BD%E6%9B%B4%E5%A4%9A.html</guid>
        
        <category>gsap</category>
        
        <category>react</category>
        
        <category>pull to refresh</category>
        
        <category>push to load more</category>
        
        
      </item>
    
      <item>
        <title>在Babel6中使用ES7 Decorator</title>
        <description>&lt;p&gt;在做下拉的时候搜寻到的&lt;a href=&quot;http://technologyadvice.github.io/es7-decorators-babel6/&quot;&gt;资料&lt;/a&gt;。&lt;/p&gt;

&lt;h1 id=&quot;decorator&quot;&gt;增加decorator支持&lt;/h1&gt;
&lt;p&gt;&lt;em&gt;假设你已经安装过 &lt;code&gt;babel-preset-2015&lt;/code&gt; 和 &lt;code&gt;babel-preset-react&lt;/code&gt; 等，并配置完毕。&lt;/em&gt;&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;npm install --save-dev babel-plugin-transform-decorators-legacy
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;然后在 &lt;code&gt;.babelrc&lt;/code&gt; 中添加：&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;{
  &quot;plugins&quot;: [&quot;transform-decorators-legacy&quot;]
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;或者在webpack配置文件中：&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;module: {
  loaders: [
    {
      test: /\.js$/,
      exclude: /node_modules\/(?!(stardust))/,
      loader: &#39;babel&#39;,
      query: {
        plugins: [
          &#39;transform-decorators-legacy&#39;,
        ]
      },
    }
  ]
}
&lt;/code&gt;&lt;/pre&gt;

&lt;h1 id=&quot;section&quot;&gt;使用方式&lt;/h1&gt;
&lt;p&gt;在我项目代码中使用了&lt;a href=&quot;https://github.com/gajus/react-css-modules&quot;&gt;react-css-modules&lt;/a&gt;。原来是这样的：&lt;/p&gt;

&lt;pre&gt;&lt;code class=&quot;language-js&quot;&gt;import CSSModules from &#39;react-css-modules&#39;;
import styles from &#39;app.css&#39;;
import {Component} from &#39;react&#39;

class A extends Component {

}

export default CSSModules(A, styles, {allowMultiple: true});
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;使用之后是这样的：&lt;/p&gt;

&lt;pre&gt;&lt;code class=&quot;language-js&quot;&gt;import CSSModules from &#39;react-css-modules&#39;;
import styles from &#39;app.css&#39;;
import {Component} from &#39;react&#39;

@CSSModules(styles, {allowMultiple: true})
class A extends Component {

}

export default A;
&lt;/code&gt;&lt;/pre&gt;

&lt;h1 id=&quot;section-1&quot;&gt;总结&lt;/h1&gt;
&lt;p&gt;为什么要用decorator？在实现下拉的时候，我就在想，如果能在实现一个动画效果后，能应用到任意组件上就好了，所以才找到了decorator。&lt;/p&gt;

&lt;p&gt;参考：&lt;/p&gt;

&lt;p&gt;-&lt;a href=&quot;http://jamesknelson.com/structuring-react-applications-higher-order-components/&quot;&gt;Structuring React Applications: Higher-Order Components&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;-&lt;a href=&quot;https://medium.com/@cheapsteak/reusing-reacttransitiongroup-animations-with-higher-order-components-1e7043451f91#.61d51t159&quot;&gt;Reusing ReactTransitionGroup animations with Higher-order Components&lt;/a&gt;&lt;/p&gt;
</description>
        <pubDate>Tue, 10 Jan 2017 00:00:00 +0800</pubDate>
        <link>https://techctu.github.io//2017/01/10/%E5%9C%A8babel6%E4%B8%AD%E4%BD%BF%E7%94%A8es7-decorator.html</link>
        <guid isPermaLink="true">https://techctu.github.io//2017/01/10/%E5%9C%A8babel6%E4%B8%AD%E4%BD%BF%E7%94%A8es7-decorator.html</guid>
        
        <category>babel</category>
        
        <category>decorator</category>
        
        
      </item>
    
      <item>
        <title>2016年年终总结</title>
        <description>&lt;p&gt;一年一度的年终总结又开始了，前几年的年终总结要么拖着拖着就没写了，要么就是写了忘了放哪了。今年把之前的博客从国外的托管主机上的WordPress博客放到了github上，然后用七牛去做了一下镜像缓存，码字和发布的体验提升了不少，也就有了那么一点写年终总结的兴致。&lt;/p&gt;

&lt;p&gt;今年整个部门最重要的工作就是三大平台的建设，年初我参与了部分WLAN建设工作，之后的主要工作是负责其中一个子中心的前端建设工作。&lt;/p&gt;

&lt;h1 id=&quot;section&quot;&gt;前端建设&lt;/h1&gt;

&lt;blockquote&gt;
  &lt;p&gt;我是我行一块砖，哪有需要往哪搬。&lt;/p&gt;
&lt;/blockquote&gt;

&lt;h2 id=&quot;section-1&quot;&gt;履历背景&lt;/h2&gt;
&lt;p&gt;最开始的时候，其实我是做后端的。这里的后端是我们部门成立的时候用Spring、Zookeeper、Dubbo、Quartz等搭建的架构。2013年那时候P2P特别火，我负责的是P2P投资流程的设计和开发。那时候的感触就是，数据库设计中一定的冗余是必要的，范式不一定合适；外系统的东西一定要在接口层隔离；日志要清晰，生产环境不允许debug。&lt;/p&gt;

&lt;p&gt;14年的时候部门重构了系统，对各个子项目进行了拆分，这个时候就体现出了设计模式原则的重要性。之前我们就要求尽可能隔离外部系统、外部接口对内部的影响，所以重构的时候基本没有对现有项目产生大的影响。&lt;/p&gt;

&lt;p&gt;后来就去做了几个新业务的APP开发，接触了一个非常魔幻的开发框架，是&lt;a href=&quot;http://www.rytong.com/?p=1063&quot;&gt;这个公司&lt;/a&gt;提供的。该框架是在Objective-C和Java上包了一个lua解释器，使用lua来进行开发。那阵子主要负责跟业务谈需求，然后再用Axure画UE，再盯开发实现和UE、UI有什么差距。&lt;/p&gt;

&lt;p&gt;2015年的时候主要是做APP，使用那个魔幻框架，深切感受到了开发工具的重要性。没有高亮、没有自动格式化、没有错误提示、没有自动补全，这样的开发体验非常不友好，极大降低了开发效率，一些设计上的原则和规范也很难顺利执行。&lt;/p&gt;

&lt;blockquote&gt;
  &lt;p&gt;Q:为什么使用这个框架？A:（假装没听见这个问题）&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;年底研究了支付宝、微信支付等接口，在这个魔幻框架上实现了第三方APP和浏览器调起客户端支付的功能。&lt;/p&gt;

&lt;p&gt;2016年初主要是参与一个WLAN建设的项目，毕竟我行网点众多，像这种在一般小饭馆提供WiFi服务的项目，规模上去了，就会出现很多问题。&lt;/p&gt;

&lt;p&gt;之后，就是建设子中心前端了。&lt;/p&gt;

&lt;h2 id=&quot;section-2&quot;&gt;第一版前端&lt;/h2&gt;
&lt;p&gt;第一版前端如果从立项开始计算，经历了7个月。从成果上看，是一个APP的四个主页面中的一个页面及其后续流程。对于互联网公司来说，太慢了；但对于我行来说，这是一个了不起的成就了。毕竟，12月开始讨论需求，讨论到了3月底，还要改UE原型。原计划是5月上线，最后推到了6月。&lt;/p&gt;

&lt;p&gt;第一版碰到了许多坑，可能有很多我都忘了，得好好想想。这是我接触前端技术的开始，也是接触工程化开始思维侧重点向工程化偏移的开始。&lt;/p&gt;

&lt;p&gt;刚开始的时候，大佬说用react吧，Facebook的react很火啊很火啊，我们一堆萌新狂点头好呀好呀你是大佬你说什么都是对的，然后就上了react。DEMO，或者说流行的叫法为starter-kit，迅速搭建了起来，一切看起来很美好。&lt;/p&gt;

&lt;h3 id=&quot;amazeui&quot;&gt;舍弃AmazeUI&lt;/h3&gt;
&lt;p&gt;大佬们说，工期紧啊，用react框架吧！然后找了一个画风看起来小清新的&lt;a href=&quot;http://amazeui.org/&quot;&gt;啊妹子UI&lt;/a&gt;。&lt;/p&gt;

&lt;p&gt;当时的AmazeUI，组件难用，耦合高，使用起来感觉很重，代码质量也不高，而且不方便根据我们的需求进行定制。当然当时react还年轻，各个框架也不成熟，包括阿里的Ant-Design。不是说不好，但这些框架比较适合的还是作为中后台的管理系统前端框架，不适合我们进行定制开发。而且页面可以服用的部分不多，不需要过度追求组件化。&lt;/p&gt;

&lt;p&gt;于是乎，我们就把啊妹子UI舍弃了。&lt;/p&gt;

&lt;p&gt;&lt;em&gt;后期啊妹子UI好像招到了一个比较牛的人，整个画风都不一样了。&lt;/em&gt;&lt;/p&gt;

&lt;h3 id=&quot;https&quot;&gt;全站HTTPS&lt;/h3&gt;
&lt;p&gt;放公网测试的时候，发生了一件非常尴尬的事情。运营商真是非常牛逼的，一言不合就往你的页面塞广告。这我能怎么办呢？没办法，全站HTTPS吧。&lt;/p&gt;

&lt;h3 id=&quot;section-3&quot;&gt;地理位置定位&lt;/h3&gt;
&lt;p&gt;一般浏览器中使用的为IP定位和window.navigator.geolocation来获取经纬度定位。IP定位不准，geolocation定位受限于浏览器（webview）内核，如果用户刷机，甚至可能无法连接定位服务（被墙你懂的）。&lt;/p&gt;

&lt;p&gt;那么，使用百度地图JS API吧！然后换全站HTTPS之后，百度地图JS API出现各种问题。&lt;/p&gt;

&lt;p&gt;&lt;em&gt;高德没有试过，有机会可以试试。&lt;/em&gt;&lt;/p&gt;

&lt;p&gt;还好有万能的第三方APP提供他们的定位接口，才能解决这个定位问题。&lt;/p&gt;

&lt;h3 id=&quot;app&quot;&gt;第三方APP内的路由&lt;/h3&gt;
&lt;p&gt;这又是个神奇的问题。在第三方APP里，你是要调用APP提供的接口来登录和支付的。调用登录和支付，会切换webview，导致原生的history返回出错。同时，第三方给的入口页面有第三方自己的header和footer，进入二级页面也会切换webview。&lt;/p&gt;

&lt;p&gt;只能自己记录一个栈，实现自己的返回方法了。简单来说就是在本地记录一个访问栈，每次访问新页面的时候把地址压入栈，返回的时候出栈。第一版使用的是Cookie，在react-router的onEnter方法中注入，避免路由影响页面部分的开发。&lt;/p&gt;

&lt;p&gt;这个方法存在一定的问题，难以记录当前页面状态，如多个页面的表单填写，需要保存当前表单的填写字段时，或是一个列表做了筛选操作时，需要做一定的特殊处理；需要清理Cookie；Cookie在会带入请求增加请求大小等。&lt;/p&gt;

&lt;h3 id=&quot;section-4&quot;&gt;开发部署流程改进&lt;/h3&gt;
&lt;p&gt;初始的starter-kit中，虽然在webpack的配置文件里配置了css-loader、style-loader、url-loader来处理样式、图片等资源，但在实际使用过程中，只在入口html文件里引入了样式文件 &lt;code&gt;&amp;lt;link src=&quot;app.css&quot;&amp;gt;&lt;/code&gt; ，并没有考虑css、图片的压缩、优化等处理。为了将css、图片等资源纳入管理，使用了inline css方式，将css、图片也像js一样引入进来，并使用loader来处理，编写了示例代码，修改了文件输出方式增加了哈希值。&lt;/p&gt;

&lt;p&gt;因为我厂采用的是采购外部厂商设计UI实现静态页面，我们利用静态页面来开发的合作方式，引入了react-css-modules来处理样式，避免编写内联样式，优化开发体验。&lt;/p&gt;

&lt;h3 id=&quot;section-5&quot;&gt;小结&lt;/h3&gt;
&lt;ul&gt;
  &lt;li&gt;产品上线使用，初步搭建了前端开发部署框架和规范化的流程。&lt;/li&gt;
  &lt;li&gt;存在一些优化方面的问题。&lt;/li&gt;
  &lt;li&gt;路由全部由前端控制，使用的hashHistory，没有后端渲染。没有自动化测试。&lt;/li&gt;
  &lt;li&gt;没有执行Eslint。&lt;/li&gt;
&lt;/ul&gt;

&lt;h2 id=&quot;section-6&quot;&gt;第二版前端&lt;/h2&gt;
&lt;p&gt;第二版前端主要在第一版基础上进行了一些改造。&lt;/p&gt;

&lt;h3 id=&quot;browserhistory&quot;&gt;替换为browserHistory&lt;/h3&gt;
&lt;blockquote&gt;
  &lt;p&gt;#后面应该是锚点，url应该就是/，为什么路由要用#？2016年了还#，你这是搞事情！&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;代码洁癖：保持和最广泛的规范一致，不要搞事情。&lt;/p&gt;

&lt;p&gt;修改点：
- 前后端的uri前缀配置。
- 页面跳转方式使用browserHistory.push。
- 修改打包时各种静态资源的相对路径注入方式。&lt;/p&gt;

&lt;h3 id=&quot;section-7&quot;&gt;修改跨页面变量存储方式&lt;/h3&gt;
&lt;p&gt;封装了Cookie和localStorage，自动判断本地是否支持localStorage，优先使用localStorage；如果强制要求使用Cookie则使用Cookie。&lt;/p&gt;

&lt;h3 id=&quot;app-1&quot;&gt;抽取第三方APP相关的接口代码&lt;/h3&gt;
&lt;p&gt;将路由、登录、支付代码从页面代码和内部公共代码部分抽离，以备后期代码复用时配置化管理。&lt;/p&gt;

&lt;h3 id=&quot;section-8&quot;&gt;部署配置纳入管理&lt;/h3&gt;
&lt;p&gt;最近投产发生了替换静态资源后大面积出现404的问题，原因是之前应该投产的配置文件修改由于种种原因没有投产，导致出错。现将配置文件纳入管理。&lt;/p&gt;

&lt;h1 id=&quot;section-9&quot;&gt;团队建设&lt;/h1&gt;
&lt;p&gt;严格来说，技术团队的建设谈不上特别复杂，相对来说比较单纯——你技术强大家就会听你的。只不过在我们的开发中技术团队的构成比较复杂一点：&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;成员构成为我、入职新人、厂商的驻场开发人员。&lt;/li&gt;
  &lt;li&gt;前端开发由另外的厂商提供静态页面，再由上述三类开发人员开发。&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;按照“看山”的分法，大部分的开发人员停留在“看山是山”的程度，并不了解隐藏在背后的思量。作为前端建设的负责人，我不可能也不应该完成前端的大部分编码，而是要挑选适合的人选进行培养，然后在保证质量的前提上，提高团队工作的效率，减少bug率，提高整个团队的水准。&lt;/p&gt;

&lt;p&gt;实际上，我并没有特地对人员进行培养，只是提供了不少参考文档和示例代码，布置了一些开发任务，然后期待他们的主观能动性。如何培养人才？这方面一直是我欠缺的，希望来年在这方面多下功夫。&lt;/p&gt;

</description>
        <pubDate>Sat, 17 Dec 2016 00:00:00 +0800</pubDate>
        <link>https://techctu.github.io//2016/12/17/2016%E5%B9%B4%E5%B9%B4%E7%BB%88%E6%80%BB%E7%BB%93.html</link>
        <guid isPermaLink="true">https://techctu.github.io//2016/12/17/2016%E5%B9%B4%E5%B9%B4%E7%BB%88%E6%80%BB%E7%BB%93.html</guid>
        
        <category>年终总结</category>
        
        <category>其他</category>
        
        
      </item>
    
      <item>
        <title>x-www-form-urlencoded、json和@RequestParam、@RequestBody</title>
        <description>&lt;p&gt;临近下班碰到新人有个bug找不到原因，症状是发送了ajax请求后后台收不到数据。经过跟踪，发现请求头为&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;Accept:*/*
Accept-Encoding:gzip, deflate, br
Accept-Language:zh-CN,zh;q=0.8,ja;q=0.6,en-US;q=0.4,en;q=0.2,zh-TW;q=0.2
Connection:keep-alive
Content-Length:112
Content-Type:application/json
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;而后台使用Spring-MVC。Controller中的获取报文方式为@RequestParam。这是导致无法接受到参数的原因。&lt;/p&gt;

&lt;h1 id=&quot;requestparamrequestbody&quot;&gt;@RequestParam和@RequestBody&lt;/h1&gt;
&lt;p&gt;@RequestParam为Spring提供的注解，对应处理String类型的body参数，如 &lt;code&gt;a=1&amp;amp;b=2&lt;/code&gt; 这类。&lt;/p&gt;

&lt;p&gt;@RequestBody同为Spring提供的注解，对应处理非String类型的body参数，如json。&lt;/p&gt;

&lt;p&gt;以上需要在Spring里进行配置。&lt;/p&gt;
</description>
        <pubDate>Wed, 07 Dec 2016 00:00:00 +0800</pubDate>
        <link>https://techctu.github.io//2016/12/07/x-www-form-urlencoded%E5%92%8Cjson.html</link>
        <guid isPermaLink="true">https://techctu.github.io//2016/12/07/x-www-form-urlencoded%E5%92%8Cjson.html</guid>
        
        <category>Context-Type</category>
        
        <category>HTTP</category>
        
        <category>Java</category>
        
        <category>Spring</category>
        
        
      </item>
    
      <item>
        <title>在iOS APP内部使用JS访问webview时uri的查询参数需要encode两次</title>
        <description>&lt;h1 id=&quot;section&quot;&gt;背景&lt;/h1&gt;
&lt;p&gt;最近在使用开发运行于第三方APP内的SPA时，需要打开浏览器访问百度地图。APP提供了一个 &lt;code&gt;[prefix-to-open-browser]/[url-to-visit]&lt;/code&gt; 的格式，可以在webview内使用 &lt;code&gt;window.location.href = &#39;[prefix-to-open-browser]/[url-to-visit]&#39;&lt;/code&gt; 的方法来打开浏览器。&lt;/p&gt;

&lt;h1 id=&quot;section-1&quot;&gt;问题&lt;/h1&gt;
&lt;p&gt;使用 &lt;code&gt;[prefix-to-open-browser]/https://www.baidu.com&lt;/code&gt; 时没有问题，但uri中包含中文参数时，使用 &lt;code&gt;encodeURI([uri])&lt;/code&gt; 无法打开浏览器。&lt;/p&gt;

&lt;h1 id=&quot;section-2&quot;&gt;跟踪&lt;/h1&gt;
&lt;p&gt;在浏览器中进行测试，&lt;code&gt;encodeURI&lt;/code&gt; 确实能将uri中的字符串进行编码：&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;encodeURI之前：https://www.baidu.com/s?wd=编码

encodeURI之后：https://www.baidu.com/s?wd=%E7%BC%96%E7%A0%81
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;而在APP内部获取到的却是 &lt;code&gt;https://www.baidu.com/s?wd=编码&lt;/code&gt;，导致APP无法打开浏览器。&lt;/p&gt;

&lt;h1 id=&quot;section-3&quot;&gt;解决&lt;/h1&gt;
&lt;p&gt;最后在浏览器中发现，&lt;strong&gt;encodeURI之后，在浏览器中访问时，会自动decodeURI一次&lt;/strong&gt;。在使用两次encodeURI之后，就解决了这个问题。&lt;/p&gt;
</description>
        <pubDate>Tue, 08 Nov 2016 00:00:00 +0800</pubDate>
        <link>https://techctu.github.io//2016/11/08/%E5%9C%A8ios-app%E5%86%85%E9%83%A8%E4%BD%BF%E7%94%A8js%E8%AE%BF%E9%97%AEwebview%E6%97%B6uri%E7%9A%84%E6%9F%A5%E8%AF%A2%E5%8F%82%E6%95%B0%E9%9C%80%E8%A6%81encode%E4%B8%A4%E6%AC%A1.html</link>
        <guid isPermaLink="true">https://techctu.github.io//2016/11/08/%E5%9C%A8ios-app%E5%86%85%E9%83%A8%E4%BD%BF%E7%94%A8js%E8%AE%BF%E9%97%AEwebview%E6%97%B6uri%E7%9A%84%E6%9F%A5%E8%AF%A2%E5%8F%82%E6%95%B0%E9%9C%80%E8%A6%81encode%E4%B8%A4%E6%AC%A1.html</guid>
        
        <category>iOS</category>
        
        <category>webview</category>
        
        <category>javascript</category>
        
        <category>js</category>
        
        <category>uri</category>
        
        <category>encode</category>
        
        <category>encodeURI</category>
        
        
      </item>
    
      <item>
        <title>为什么使用react/使用react有什么好处？</title>
        <description>&lt;p&gt;接手前端后，摸着石头过河，采用推荐的新的react框架，踩过不少坑，终于项目平稳上线。随之而来就会有许多人问：&lt;/p&gt;

&lt;blockquote&gt;
  &lt;p&gt;为什么要使用react？react有什么好处？和jQuery/velocity/bootstrap/AngularJS/Vue.js相比有什么优点？&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;其中我只用过jQuery+velocity，用过一点bootstrap，AngularJS和Vue.js都是道听途说，没有真正接触，不敢妄加评论，只能从自身经历，提供一点浅见。&lt;/p&gt;

&lt;h1 id=&quot;section&quot;&gt;问题的本质&lt;/h1&gt;
&lt;p&gt;这个问题的应该需求分析一下：&lt;/p&gt;

&lt;ol&gt;
  &lt;li&gt;使用react开发H5页面复杂吗？对新人的学习曲线怎么样？开发是否方便快捷？调试是否方便？&lt;/li&gt;
  &lt;li&gt;react能解决哪些方面的问题？不能解决哪些方面的问题？还需要什么补充？&lt;/li&gt;
  &lt;li&gt;好像没有3了。&lt;/li&gt;
&lt;/ol&gt;

&lt;h1 id=&quot;react&quot;&gt;React和现在使用的相关技术&lt;/h1&gt;
&lt;p&gt;首先，重申一点，react是一个UI框架，更正确的说法，应该只是提供了构建自己的UI框架的底层库。举个栗子，蚂蚁金服的ant design和啊妹子UI，都可以说是基于react构建的UI框架，包含了大家熟悉的按钮、轮播图、单选按钮组等组件。&lt;/p&gt;

&lt;p&gt;而前端的客户端部分，也是存在MVC，或者流行的MV*结构的。所以，react肯定是需要其他方面技术补充的。&lt;/p&gt;

&lt;blockquote&gt;
  &lt;p&gt;为什么不直接使用ant design/Amaze UI？&lt;/p&gt;
&lt;/blockquote&gt;

&lt;pre&gt;&lt;code&gt;我们构建的是面客系统，会有自己的设计风格，而使用ant design或是其他框架，其框架太重，不适合按照我们的特殊需求进行定制。这类框架比较适合内部系统或者是管理系统使用。
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;由于React只是一个底层库，所以react需要一些其他的技术来构建SPA（单页面应用），如：依赖管理和打包的webpack、前端路由react-router、状态管理flux/redux/reflux等。&lt;/p&gt;

&lt;p&gt;下面从我的经验介绍一下React及其系列相关技术的优缺点。&lt;/p&gt;

&lt;h1 id=&quot;react-1&quot;&gt;React开发的优点&lt;/h1&gt;
&lt;p&gt;React的开发其实是一件非常简单的事情。React的开发除了一个由于保留字需要把HTML的 &lt;code&gt;class&lt;/code&gt; 替换成 &lt;code&gt;className&lt;/code&gt;，剩下的就是专注于使用流程和状态来控制页面（JavaScript），以及将状态对应到正确的样式上（JSX）。&lt;/p&gt;

&lt;h2 id=&quot;section-1&quot;&gt;简单，封装&lt;/h2&gt;
&lt;p&gt;如果使用过jQuery的第三方组件，或者bootstrap等，一旦页面比较复杂，就会碰到重命名、选择器等问题；如果使用过AngularJS，或者一些其他模板引擎，一定会学习这些库特有的一些语法，或是标签，如：&lt;/p&gt;

&lt;figure class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-js&quot; data-lang=&quot;js&quot;&gt;&lt;span class=&quot;c1&quot;&gt;// AngularJS的循环遍历&lt;/span&gt;
&lt;span class=&quot;o&quot;&gt;&amp;lt;&lt;/span&gt;&lt;span class=&quot;nx&quot;&gt;ul&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;&amp;gt;&lt;/span&gt;
  &lt;span class=&quot;o&quot;&gt;&amp;lt;&lt;/span&gt;&lt;span class=&quot;nx&quot;&gt;li&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;*&lt;/span&gt;&lt;span class=&quot;nx&quot;&gt;ngFor&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;=&lt;/span&gt;&lt;span class=&quot;s2&quot;&gt;&amp;quot;#hero of heroes&amp;quot;&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;&amp;gt;&lt;/span&gt;
    
  &lt;span class=&quot;o&quot;&gt;&amp;lt;&lt;/span&gt;&lt;span class=&quot;err&quot;&gt;/li&amp;gt;&lt;/span&gt;
&lt;span class=&quot;o&quot;&gt;&amp;lt;&lt;/span&gt;&lt;span class=&quot;err&quot;&gt;/ul&amp;gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/figure&gt;

&lt;p&gt;而在react里，你只需要会HTML和JavaScript。什么是jsx？&lt;/p&gt;

&lt;p&gt;这是html：&lt;/p&gt;

&lt;figure class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-html&quot; data-lang=&quot;html&quot;&gt;    &lt;span class=&quot;nt&quot;&gt;&amp;lt;div&lt;/span&gt; &lt;span class=&quot;na&quot;&gt;style=&lt;/span&gt;&lt;span class=&quot;s&quot;&gt;&amp;quot;background-color: #fff;&amp;quot;&lt;/span&gt;&lt;span class=&quot;nt&quot;&gt;&amp;gt;&lt;/span&gt;这是HTML&lt;span class=&quot;nt&quot;&gt;&amp;lt;/div&amp;gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/figure&gt;

&lt;p&gt;这是JavaScript（ECMAScript 2015/ES6）：&lt;/p&gt;

&lt;figure class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-js&quot; data-lang=&quot;js&quot;&gt;&lt;span class=&quot;kr&quot;&gt;class&lt;/span&gt; &lt;span class=&quot;nx&quot;&gt;SomeClass&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;
    &lt;span class=&quot;nx&quot;&gt;functionA&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;()&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;
        &lt;span class=&quot;k&quot;&gt;return&lt;/span&gt; &lt;span class=&quot;kc&quot;&gt;null&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;
    &lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;
&lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/figure&gt;

&lt;p&gt;这是JSX：&lt;/p&gt;

&lt;figure class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-js&quot; data-lang=&quot;js&quot;&gt;&lt;span class=&quot;kd&quot;&gt;let&lt;/span&gt; &lt;span class=&quot;nx&quot;&gt;myDivElement&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;&amp;lt;&lt;/span&gt;&lt;span class=&quot;nx&quot;&gt;div&lt;/span&gt; &lt;span class=&quot;nx&quot;&gt;className&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;=&lt;/span&gt;&lt;span class=&quot;s2&quot;&gt;&amp;quot;foo&amp;quot;&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;/&amp;gt;&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;
&lt;span class=&quot;nx&quot;&gt;ReactDOM&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;nx&quot;&gt;render&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;nx&quot;&gt;myDivElement&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;nb&quot;&gt;document&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;nx&quot;&gt;getElementById&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;s1&quot;&gt;&amp;#39;example&amp;#39;&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;));&lt;/span&gt;

&lt;span class=&quot;c1&quot;&gt;// 更高级一点，自定义组件&lt;/span&gt;
&lt;span class=&quot;kr&quot;&gt;class&lt;/span&gt; &lt;span class=&quot;nx&quot;&gt;MyComponent&lt;/span&gt; &lt;span class=&quot;kr&quot;&gt;extends&lt;/span&gt; &lt;span class=&quot;nx&quot;&gt;React&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;nx&quot;&gt;Component&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;
    &lt;span class=&quot;c1&quot;&gt;// 面向对象中眼熟的继承&lt;/span&gt;
    &lt;span class=&quot;nx&quot;&gt;constructor&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;nx&quot;&gt;props&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;
        &lt;span class=&quot;c1&quot;&gt;// react封装的自定义组件的参数传递方式&lt;/span&gt;
        &lt;span class=&quot;k&quot;&gt;this&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;nx&quot;&gt;state&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;
            &lt;span class=&quot;nx&quot;&gt;hello&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;:&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;this&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;nx&quot;&gt;props&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;nx&quot;&gt;hello&lt;/span&gt;
        &lt;span class=&quot;p&quot;&gt;};&lt;/span&gt;
    &lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;

    &lt;span class=&quot;c1&quot;&gt;// react的组件渲染方法&lt;/span&gt;
    &lt;span class=&quot;nx&quot;&gt;render&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;()&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;
        &lt;span class=&quot;k&quot;&gt;return&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;
            &lt;span class=&quot;o&quot;&gt;&amp;lt;&lt;/span&gt;&lt;span class=&quot;nx&quot;&gt;div&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;&amp;gt;&lt;/span&gt;
                &lt;span class=&quot;o&quot;&gt;&amp;lt;&lt;/span&gt;&lt;span class=&quot;nx&quot;&gt;label&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;&amp;gt;&lt;/span&gt;&lt;span class=&quot;err&quot;&gt;自定义&lt;/span&gt;&lt;span class=&quot;nx&quot;&gt;react&lt;/span&gt;&lt;span class=&quot;err&quot;&gt;组件&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;&amp;lt;&lt;/span&gt;&lt;span class=&quot;err&quot;&gt;/label&amp;gt;&amp;lt;lable&amp;gt;{this.state.hello}&amp;lt;/lable&amp;gt;&lt;/span&gt;
            &lt;span class=&quot;o&quot;&gt;&amp;lt;&lt;/span&gt;&lt;span class=&quot;err&quot;&gt;/div&amp;gt;)&lt;/span&gt;
    &lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;
&lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;

&lt;span class=&quot;kd&quot;&gt;let&lt;/span&gt; &lt;span class=&quot;nx&quot;&gt;hello&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;s1&quot;&gt;&amp;#39;world&amp;#39;&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;
&lt;span class=&quot;kd&quot;&gt;let&lt;/span&gt; &lt;span class=&quot;nx&quot;&gt;myDivElement&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;&amp;lt;&lt;/span&gt;&lt;span class=&quot;nx&quot;&gt;MyComponent&lt;/span&gt; &lt;span class=&quot;nx&quot;&gt;hello&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;=&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;&lt;span class=&quot;nx&quot;&gt;hello&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;/&amp;gt;&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt; &lt;span class=&quot;c1&quot;&gt;// 给自定义组件传参&lt;/span&gt;
&lt;span class=&quot;nx&quot;&gt;ReactDOM&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;nx&quot;&gt;render&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;nx&quot;&gt;myDivElement&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;nb&quot;&gt;document&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;nx&quot;&gt;getElementById&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;s1&quot;&gt;&amp;#39;example&amp;#39;&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;));&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/figure&gt;

&lt;p&gt;JSX很简单，就是在js中使用HTML标签组成的HTML片段，&lt;strong&gt;没有奇怪的属性，标签，方法&lt;/strong&gt;，&lt;strong&gt;没有奇怪的属性，标签，方法&lt;/strong&gt;，&lt;strong&gt;没有奇怪的属性，标签，方法&lt;/strong&gt;，我喜欢的特性说三遍。&lt;/p&gt;

&lt;p&gt;所以，react的核心思想就是，让开发人员关注业务流程变化导致的状态变化，将状态对应到具体的页面展示上，而对DOM的操作，交给react来进行。这样的方式，非常适用于目前由第三方出静态页面，我们的开发人员来实现最终效果的分工方式。&lt;/p&gt;

&lt;h2 id=&quot;section-2&quot;&gt;强大的开发工具&lt;/h2&gt;
&lt;p&gt;在Java开发的时候，我们已经习惯了代码高亮、自动补全、语法提示、源码定位、规范检查、压缩混淆打包等功能，react开发自然也是有这一系列工具的，涵盖了Sublime、Atom、VSCode等多种编辑器，还具有在Chrome、Firefox进行调试的插件。&lt;/p&gt;

&lt;p&gt;虽然经常有人吹牛说能用记事本写出千行代码，然而那只是个人能力，总不能要求所有人都具备这种能力，所以有好用的工具为何不用呢？自动化工具的使用，才利于项目的工程化，提高项目组整体的实施水平，极大提高开发效率，甚至一个好的代码高亮主题还能吸引妹子在你身后围观你编码。&lt;/p&gt;

&lt;h2 id=&quot;unix&quot;&gt;UNIX哲学&lt;/h2&gt;
&lt;p&gt;专注于解决一个问题，小而精，而非大而全。&lt;/p&gt;

&lt;p&gt;尤其是在我们目前使用SpringMVC处理动态请求，使用nginx处理静态请求的架构下；具有自己的UE和UI设计的条件下，那些大而全的现有框架的一些隐蔽的使用条件，如某些库所需的支持等，和按照设计对一些内容进行改造等，非常繁琐不便利。&lt;/p&gt;

&lt;p&gt;React提供了一个完整的UI渲染更新流程，设计了一个组件封装的生命周期。使用react，将DOM操作交给react，能使开发人员专注于业务流程，减少繁琐的DOM操作的开发，降低由于DOM操作导致的bug（在使用jQuery的年代很常见，bootstrap也是，很多以HTML为设计核心的难以封装模板引擎也是）。&lt;/p&gt;

&lt;p&gt;使用小而精的工具，能使我们对手中的项目了若指掌，避免莫名的问题。&lt;/p&gt;

&lt;h2 id=&quot;section-3&quot;&gt;丰富的库支持&lt;/h2&gt;
&lt;p&gt;&lt;a href=&quot;https://www.npmjs.com/search?q=react&quot;&gt;21465 results for ‘react’.&lt;/a&gt;&lt;/p&gt;

&lt;h2 id=&quot;section-4&quot;&gt;社区和文档支持等&lt;/h2&gt;
&lt;p&gt;React具有&lt;a href=&quot;https://facebook.github.io/react/docs/getting-started.html&quot;&gt;比较详细的文档&lt;/a&gt;、&lt;a href=&quot;https://facebook.github.io/react/docs/videos.html&quot;&gt;教学视频&lt;/a&gt;和大量的&lt;a href=&quot;https://github.com/facebook/react/wiki/Examples&quot;&gt;示例代码、脚手架&lt;/a&gt;，在&lt;a href=&quot;https://github.com/&quot;&gt;某知名大型国际同性交友网站&lt;/a&gt;上能找到&lt;a href=&quot;https://github.com/search?utf8=%E2%9C%93&amp;amp;q=react&quot;&gt;10W+相关代码&lt;/a&gt;。&lt;/p&gt;

&lt;h1 id=&quot;react-2&quot;&gt;React开发的缺点&lt;/h1&gt;
&lt;p&gt;大致说完了优点，来说说缺点。&lt;/p&gt;

&lt;h2 id=&quot;javascript&quot;&gt;JavaScript发展快速，导致了混乱&lt;/h2&gt;
&lt;p&gt;这几年是JavaScript，嗯，ECMAScript发展迅速的一年，前端相关们都各有各的野心，浏览器厂商和标准组织合纵连横，谷歌微软苹果互相掐架，微软Mozilla眉来眼去，两年就从ES5到了ES6眼看着又要马不停蹄奔向ES7了，这就导致目前百度搜索到的react示例大部分使用ES5，一部分使用ES6，少量使用ES7，&lt;strong&gt;不利于初学者学习&lt;/strong&gt;，尤其是大部分人都是从学习&lt;a href=&quot;http://www.ruanyifeng.com/blog/2015/03/react.html&quot;&gt;写blog写到阿里的某大牛&lt;/a&gt;开始。&lt;/p&gt;

&lt;p&gt;而我们，使用的是ES6。&lt;/p&gt;

&lt;p&gt;&lt;em&gt;注：JavaScript是ECMA-262标准的实现和扩展，我们使用的ES6基于ECMA-262 6th Edition。&lt;/em&gt;&lt;/p&gt;

&lt;h2 id=&quot;section-5&quot;&gt;太多工具&lt;/h2&gt;
&lt;p&gt;既然要拥抱UNIX哲学，那么就会面临大量工具选择的问题：编辑器、构建、脚手架、规则校验、测试等，都需要进行选择、配置，以便项目组进行开发。&lt;/p&gt;

&lt;p&gt;&lt;em&gt;虽然我写了一些工具配置使用说明，但不知为何很多人还是使用一个没有安装任何插件的Sublime/Atom进行开发，难道都是记事本写十万行不出bug的大牛？&lt;/em&gt;&lt;/p&gt;

&lt;h2 id=&quot;react-3&quot;&gt;React设计思想&lt;/h2&gt;
&lt;p&gt;React和相关系列技术的设计思想，是开发人员使用react的最大门槛。&lt;/p&gt;

&lt;p&gt;React的willMount-didMount-willReceiveProps-shouldUpdate-willUpdate-didUpdate-willUnmount的生命周期，规范了DOM的更新，同时也提高了学习门槛。开发人员需要了解何时重写生命周期方法，这就要求开发人员对页面可能发生的状态迁移和目标结果有充分了解。事实上，我觉得，开发人员也应该清楚页面的状态迁移和目标结果——至少是大部分的。&lt;/p&gt;

&lt;p&gt;同时，react支持多种创建组件的方式：React.createClass、ES6 Classes和stateless functional components（无状态组件）。&lt;/p&gt;

&lt;p&gt;应该使用哪个方式？开发人员会面临混乱。&lt;/p&gt;

&lt;p&gt;React官方指出应该分为两层：使用无状态组件渲染页面各个部分；使用ES6 Classes保持页面状态；React.createClass是ES5及其之前的东西，请勿使用——恰巧这是目前国内大部分示例使用的方式。&lt;/p&gt;

&lt;p&gt;同时目前由于页面不是很复杂所以没有采用的各大状态管理机制，也暂时降低了开发难度。&lt;/p&gt;

&lt;p&gt;&lt;em&gt;从开发的支持筛选、搜索的商户列表页来看，似乎马上也要使用flux/redux/reflux一类了，蓝瘦，香菇。&lt;/em&gt;&lt;/p&gt;

&lt;h2 id=&quot;section-6&quot;&gt;语言障碍&lt;/h2&gt;
&lt;p&gt;目前国内大部分示例停留在ES5，已过期，需要翻墙去寻找示例。&lt;/p&gt;

&lt;h1 id=&quot;section-7&quot;&gt;总结&lt;/h1&gt;
&lt;p&gt;在项目从2015年底需求研究开始到2016年4月开始一个月开发一个月测试投产上线，再到10月的二期期间，经历了接触react、webpack、ES6、react-router等到利用空档偷偷摸摸重构项目、修改目录结构、修改代码编写范例、利用非工作时间充电等，对这一系列技术有了一定的了解。&lt;/p&gt;

&lt;p&gt;总的来说，react的使用和大部分技术一样，在一个团队里，只需要一个技术比较好的人搭建了boilerplate，写了几个sample，其他人依样画葫芦就可以了。而项目质量，从来不是一门语言、一个库或者框架就能决定的。&lt;/p&gt;
</description>
        <pubDate>Mon, 10 Oct 2016 00:00:00 +0800</pubDate>
        <link>https://techctu.github.io//2016/10/10/%E4%B8%BA%E4%BB%80%E4%B9%88%E4%BD%BF%E7%94%A8react%E4%BD%BF%E7%94%A8react%E6%9C%89%E4%BB%80%E4%B9%88%E5%A5%BD%E5%A4%84.html</link>
        <guid isPermaLink="true">https://techctu.github.io//2016/10/10/%E4%B8%BA%E4%BB%80%E4%B9%88%E4%BD%BF%E7%94%A8react%E4%BD%BF%E7%94%A8react%E6%9C%89%E4%BB%80%E4%B9%88%E5%A5%BD%E5%A4%84.html</guid>
        
        <category>react</category>
        
        
      </item>
    
      <item>
        <title>react-router：从hashHistory到browserHistory</title>
        <description>&lt;p&gt;项目开始使用react-router时由于工期原因，使用了hashHistory，在url末尾会形成&lt;code&gt;/#/user/haishanh?_k=adseis&lt;/code&gt;中&lt;code&gt;_k=adseis&lt;/code&gt;的query字符串。这在浏览器中打开时会让用户感到迷惑。&lt;/p&gt;

&lt;h1 id=&quot;hashhistoryquerykey&quot;&gt;hashHistory和queryKey&lt;/h1&gt;
&lt;p&gt;在一些旧的浏览器中，不支持H5提供的新的接口如pushState，则使用了该方法生成key来读写window.sessionStorage的内容，实现页面跳转和回退时保持页面状态的功能，如类似新浪微博列表页请求了几次更多微博，进入详情页面后返回到列表页之前获取的微博仍然在里面无需重复之前的请求；又或者一个流程多个复杂表格填写，在前进、后退过程中保持之前填写的内容。&lt;/p&gt;

&lt;p&gt;在&lt;a href=&quot;http://react-china.org/t/react-router-hashhistory-browserhistory/6799/4&quot;&gt;【react-router】hashhistory 与 browserhistory有什么区别&lt;/a&gt;中有简单设置以去掉&lt;code&gt;_k=abc123&lt;/code&gt;。&lt;/p&gt;

&lt;pre&gt;&lt;code class=&quot;language-js&quot;&gt;import { createHashHistory } from &#39;history&#39;;

const appHistory = useRouterHistory(createHashHistory)({ queryKey: false });

ReactDOM.render(
  &amp;lt;Router history={appHistory}&amp;gt;
    {routes}
  &amp;lt;/Router&amp;gt;,
  document.getElementById(&#39;app&#39;)
);
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;问题：无法使用state保持页面状态，无法使用state来渲染链接对应页面，如&lt;/p&gt;

&lt;pre&gt;&lt;code class=&quot;language-js&quot;&gt;const path = {
  pathname: &#39;business/BaiduSearch/update&#39;,
  state: { id: record.id } 
}
&amp;lt;Link to={path}&amp;gt;修改&amp;lt;/Link&amp;gt;
&lt;/code&gt;&lt;/pre&gt;

&lt;h1 id=&quot;browserhistory&quot;&gt;使用browserHistory&lt;/h1&gt;
&lt;p&gt;在一些框架、库提供的糖面前，我倾向于不使用改变更广泛的标准的做法。如上面通过使用hashHistory和queryKey来获取state来渲染页面的方法，我更倾向于使用&lt;code&gt;http://example.com/the/path?the=query&amp;amp;id=recordId&lt;/code&gt;的方式获取相关信息渲染页面，这样在分享链接时也更为方便。&lt;/p&gt;

&lt;h2 id=&quot;browserhistory-1&quot;&gt;创建browserHistory&lt;/h2&gt;
&lt;p&gt;本来可以直接使用&lt;code&gt;react-router&lt;/code&gt;提供的&lt;code&gt;browserHistory&lt;/code&gt;，但考虑到该项目对应的域名为&lt;code&gt;xxx.xxx.com/xx&lt;/code&gt;，而且本地开发环境使用localhost:port访问，所以引入&lt;a href=&quot;https://www.npmjs.com/package/history&quot;&gt;history&lt;/a&gt;。&lt;/p&gt;

&lt;pre&gt;&lt;code class=&quot;language-js&quot;&gt;import {createHistory} from &#39;history&#39;
import {
  Router,
  Route,
  useRouterHistory
}
const browserHistory = useRouterHistory(createHistory)({basename: process.env.NODE_ENV === &#39;production&#39;? &#39;/xx&#39;: &#39;&#39;})
const routes = (
  &amp;lt;Router history={browserHistory}&amp;gt;
  ...
  &amp;lt;/Router&amp;gt;
)
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;同时，需要修改对应的web容器配置，使其知道/xx/下的所有uri路由到单页面应用。目前使用的nginx。&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;location /xx/ {
    try_files $uri /xx/index.html;
}
&lt;/code&gt;&lt;/pre&gt;

&lt;h2 id=&quot;state&quot;&gt;state&lt;/h2&gt;
&lt;p&gt;目前state的作用主要是提供了保持页面状态的功能，包括相关的存取功能。这部分功能可以使用很多方式实现，如history的location.state，cookie，甚至是引入redux等。&lt;/p&gt;
</description>
        <pubDate>Sun, 31 Jul 2016 00:00:00 +0800</pubDate>
        <link>https://techctu.github.io//2016/07/31/react-router%E4%BB%8Ehashhistory%E5%88%B0browserhistory.html</link>
        <guid isPermaLink="true">https://techctu.github.io//2016/07/31/react-router%E4%BB%8Ehashhistory%E5%88%B0browserhistory.html</guid>
        
        <category>react-router</category>
        
        <category>react</category>
        
        
      </item>
    
      <item>
        <title>前端重构第一次尝试后思路整理</title>
        <description>&lt;p&gt;最近做了一个项目的前端开发，上线了，然而怎么看都是一个玩具一般的东西，需要一次强力升级。前段时间也看了很多博客，翻了很多文档，对项目进行了一次小小的外科手术，但随着了解深入，收获的知识越来越多，接触到的问题也越来越多。道高一尺魔高一丈，也许也能这样解释？得整理一下思路，降服一下心魔了。&lt;/p&gt;

&lt;h1 id=&quot;section&quot;&gt;目前项目状态&lt;/h1&gt;
&lt;p&gt;初始状态：&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;参考之前jQuery + Velocity年代，目录分为css、scripts、img，scripts下分为pages和util。&lt;/li&gt;
  &lt;li&gt;项目较小，为嵌入APP webview中的H5项目，css放入一个统一的css文件中。&lt;/li&gt;
  &lt;li&gt;引入react、react-router。&lt;/li&gt;
  &lt;li&gt;使用webpack打包，只输出bundle.js到asset目录下，bundle.js和css文件直接在index.html中引用。&lt;/li&gt;
  &lt;li&gt;图片和css样式在react组件中直接以&lt;code&gt;className=&quot;class-a class-b&quot;&lt;/code&gt;和&lt;code&gt;&amp;lt;img src=&quot;../../img/a/png&quot; /&amp;gt;&lt;/code&gt;的方式使用。&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;一个这样的项目，怎么就这样上线了？除了在生产打包使用了&lt;code&gt;webpack.optimize.UglifyJsPlugin&lt;/code&gt;这种打包压缩js之外，看不到现代前端工程的痕迹。虽然是个小项目，可以不那么重视性能，但连gzip都没有开是怎么回事？一个400多k的bundle.js在webview中请求并加载运行的速度完全不能接受。而且这个项目可能要作为模板在其他项目中使用。作为一个有代码和工程洁癖的人，怎么能忍受这样的事情？&lt;/p&gt;

&lt;p&gt;然后有了之前的&lt;a href=&quot;/2016/07/11/%E5%89%8D%E7%AB%AF%E9%87%8D%E6%9E%84%E7%AC%AC%E4%B8%80%E6%AC%A1%E5%B0%9D%E8%AF%95.html&quot;&gt;进阶修改&lt;/a&gt;。&lt;/p&gt;

&lt;p&gt;此时，了解的知识和碰到的问题越来越多，如&lt;a href=&quot;https://csspod.com/frontend-performance-best-practices/&quot;&gt;前端性能优化最佳实践&lt;/a&gt;，&lt;a href=&quot;https://github.com/fouber/blog&quot;&gt;某技术总监的前端博文&lt;/a&gt;等；也发现了不少帮助解决前端工程问题的工具，如&lt;a href=&quot;http://fis.baidu.com/&quot;&gt;fis3@Baidu-FEX-team&lt;/a&gt;，&lt;a href=&quot;http://yeoman.io/&quot;&gt;yo@Google-Yeoman-team&lt;/a&gt;。已经有不少前辈趟过雷踩过坑，很多文章都很精彩，但并不一定适合我所在team的环境。也许，需要针对我厂特点进行一个定制了。&lt;/p&gt;

&lt;h1 id=&quot;section-1&quot;&gt;需求分析&lt;/h1&gt;
&lt;p&gt;现有环境：&lt;/p&gt;

&lt;ol&gt;
  &lt;li&gt;苛刻的资源权限管理：生产环境、代码资源、测试环境、外网环境等申请困难重重。&lt;/li&gt;
  &lt;li&gt;内网环境开发和部署，可以支持代理上npm。&lt;/li&gt;
  &lt;li&gt;代码版本管理可能使用TFS/SVN/Git等多种版本管理工具，目前使用TFS。&lt;/li&gt;
  &lt;li&gt;前端开发人员前端开发技能熟练度不高，对JQuery系不很熟练的程度，更不用说es6、react、组件化。&lt;/li&gt;
  &lt;li&gt;打包部署流程有待考察。&lt;/li&gt;
  &lt;li&gt;不一定适用CDN，目标运行环境主要为移动设备，包括手机、平板、笔记本。&lt;/li&gt;
  &lt;li&gt;目前为粗暴缩放，缺乏精细多屏适配设计与实现。&lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;需求：&lt;/p&gt;

&lt;ol&gt;
  &lt;li&gt;&lt;strong&gt;开发规范&lt;/strong&gt;：基于es6、react、webpack开发，要有开发规范，快速定位开发问题，提高开发效率。&lt;/li&gt;
  &lt;li&gt;&lt;strong&gt;模块化/组件化&lt;/strong&gt;：有自己的模块/组件仓库，解决命名空间、组件独立、依赖管理、按需加载执行、安全合并等问题，区分开业务相关和业务无关的模块和组件。&lt;/li&gt;
  &lt;li&gt;&lt;strong&gt;react技术&lt;/strong&gt;：使用react作为UI组件，使用react-router管理前端路由，使用redux管理前端状态，状态数据结构必须immutable。&lt;/li&gt;
  &lt;li&gt;&lt;strong&gt;性能优化&lt;/strong&gt;：通过工程化方法进行性能优化，包括加速首屏加载，图片压缩合并，CSS Sprite，Base64图片，缓存和缓存更新，性能提升统计评估等。&lt;/li&gt;
  &lt;li&gt;&lt;strong&gt;项目部署&lt;/strong&gt;：开发资源组织规则和部署资源组织规则分离，支持动静分离、静态资源缓存、CDN、非覆盖式发布等。&lt;/li&gt;
  &lt;li&gt;&lt;strong&gt;开发流程&lt;/strong&gt;：内网环境开发，支持通过代理访问外网npm，代码托管在内网windows server TFS上，构建也位于windows server，可以通过代理访问外网npm，生产构建位于windows。&lt;/li&gt;
  &lt;li&gt;&lt;strong&gt;开发工具&lt;/strong&gt;：内网开发，编辑器、IDE、构建与优化工具、开发-调试-部署等流程工具，以及组件库获取、提交等相关工具，甚至运营、文档、配置发布等平台工具。&lt;/li&gt;
  &lt;li&gt;&lt;strong&gt;协作流程&lt;/strong&gt;：业务提交需求，厂商提供UEUI和静态页面，组内开发人员根据静态页面编写react页面。&lt;/li&gt;
  &lt;li&gt;&lt;strong&gt;后台&lt;/strong&gt;：目前使用Java SpringMVC，动态请求发送POST到Controller，Service层使用Dubbo。&lt;/li&gt;
  &lt;li&gt;&lt;strong&gt;其他&lt;/strong&gt;：待发掘。&lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;分析：&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;对于第1点，前期的改造基本完成。&lt;/li&gt;
  &lt;li&gt;第2、3点需要修改目录结构，提供samples。&lt;/li&gt;
  &lt;li&gt;第4点目前已经使用了缓存、hash、gzip压缩、base64等技术，Java环境下的react首页直出有待研究。&lt;/li&gt;
  &lt;li&gt;第5、6点和本厂大环境相关，只考虑开发和打包过程，从代码仓库抽取到打包环境和打包环境到生产部署的过程和工具暂不考虑。&lt;/li&gt;
  &lt;li&gt;第7点已经编写了内网环境下搭建基于sublime的开发环境的教程。&lt;/li&gt;
  &lt;li&gt;第8点主要在于本组静态页面开发能力较弱，需要长期培养。&lt;/li&gt;
  &lt;li&gt;第9点主要用于考虑后期使用node替换SpringMVC使web前后端同构，java只负责服务层。&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;所以目前主要考虑的应该是，静态资源开发和组织的工程化，在&lt;a href=&quot;/2016/07/11/%E5%89%8D%E7%AB%AF%E9%87%8D%E6%9E%84%E7%AC%AC%E4%B8%80%E6%AC%A1%E5%B0%9D%E8%AF%95.html&quot;&gt;进阶修改&lt;/a&gt;的基础上引入redux及其相关技术，进一步组件化，构建自己的组件仓库，提供samples等。可以先研究&lt;a href=&quot;http://yeoman.io/&quot;&gt;yeoman&lt;/a&gt;这样的构造工具。国内fis3这样的工具不像yeoman这样透明直观，使用时对其机理存疑。&lt;/p&gt;
</description>
        <pubDate>Thu, 14 Jul 2016 00:00:00 +0800</pubDate>
        <link>https://techctu.github.io//2016/07/14/%E5%89%8D%E7%AB%AF%E9%87%8D%E6%9E%84%E7%AC%AC%E4%B8%80%E6%AC%A1%E5%B0%9D%E8%AF%95%E5%90%8E%E6%80%9D%E8%B7%AF%E6%95%B4%E7%90%86.html</link>
        <guid isPermaLink="true">https://techctu.github.io//2016/07/14/%E5%89%8D%E7%AB%AF%E9%87%8D%E6%9E%84%E7%AC%AC%E4%B8%80%E6%AC%A1%E5%B0%9D%E8%AF%95%E5%90%8E%E6%80%9D%E8%B7%AF%E6%95%B4%E7%90%86.html</guid>
        
        <category>react</category>
        
        <category>webpack</category>
        
        
      </item>
    
      <item>
        <title>前端重构第一次尝试</title>
        <description>&lt;p&gt;前段时间自行吐槽了自己参与大部分工作的前端项目，慢慢学习前端工作流到现在，并尝试了重构，记录一下。&lt;/p&gt;

&lt;h1 id=&quot;section&quot;&gt;配置管理&lt;/h1&gt;
&lt;p&gt;首先，把和环境相关的配置提取出来，使用webpack.DefinePlugin，避免每次部署时开发环境、测试环境、生产环境的变量手动修改。&lt;/p&gt;

&lt;pre&gt;&lt;code class=&quot;language-js&quot;&gt;/* 定义运行环境相关变量 */
var SITE_STATIC_PREFIX = &#39;/yh-wifi-web/&#39;;
/* ... */

module.exports = {
  plugins: [
    new webpack.DefinePlugin({
      SITE_STATIC_PREFIX: JSON.stringify(SITE_STATIC_PREFIX),
      SITE_DYNAMIC_PREFIX:JSON.stringify(SITE_DYNAMIC_PREFIX)
    })
  ]
}；
&lt;/code&gt;&lt;/pre&gt;

&lt;h1 id=&quot;section-1&quot;&gt;资源管理&lt;/h1&gt;
&lt;p&gt;然后，把css和图片等资源文件从在index.html里直接饮用挪到js中引用，以便将静态资源文件纳入管理，解决热部署问题（&lt;a href=&quot;http://zhihu.com/question/20790576/answer/32602154&quot;&gt;大公司里怎样开发和部署前端代码？ - 回答作者: 张云龙&lt;/a&gt;）。&lt;/p&gt;

&lt;pre&gt;&lt;code class=&quot;language-js&quot;&gt;/* 引用静态资源 */
import zoneMomImage from &#39;../../../image/mom.png&#39;;
import styles from &#39;../../../css/app.css&#39;;
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;在webpack配置中添加对应loader。&lt;/p&gt;

&lt;pre&gt;&lt;code class=&quot;language-js&quot;&gt;/* 在webpack配置中添加对应loader */
module.exports = {
  module: {
    loaders: [{
      test: /\.css$/,
      loader: loaders: [&#39;style?sourceMap&#39;, &#39;css?modules&amp;amp;camelCase&amp;amp;sourceMap&#39;],
      include: path.join(__dirname, &#39;css&#39;)
    }, {
      test: /\.(png|jpg|gif|svg)$/,
      loaders: [&#39;url?limit=8192&#39;],
      include: path.join(__dirname, &#39;image&#39;)
    }]
  }
}；
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;这样，就可以在react中使用css module。&lt;/p&gt;

&lt;pre&gt;&lt;code class=&quot;language-css&quot;&gt;.sample-camel{
  color: red;
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;在react中引用之后，可以使用对应变量表示样式&lt;/p&gt;

&lt;pre&gt;&lt;code class=&quot;language-js&quot;&gt;render(
  return &amp;lt;div className={styles.sampleCamel} /&amp;gt;
)
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;然而，考虑到现在的前端开发流程，UE-&amp;gt;UI-&amp;gt;HTML+CSS-&amp;gt;react组件，以及现有项目的修改难度，引入了&lt;a href=&quot;https://github.com/gajus/react-css-modules&quot;&gt;react-css-modules&lt;/a&gt;。&lt;/p&gt;

&lt;pre&gt;&lt;code class=&quot;language-js&quot;&gt;// ComponentSample.js
import CSSModules from &#39;react-css-modules&#39;;
// 修改className为styleName
render(
  return &amp;lt;div styleName=&quot;sample-camel&quot; /&amp;gt;
)
// 装饰组件
export default CSSModules(ComponentSample, styles, {allowMultiple:true});
// webpack配置
module.exports = {
  module: {
    loaders: [{
      test: /\.css$/,
      loader: loaders: [&#39;style?sourceMap&#39;, &#39;css?modules&amp;amp;importLoaders=1&amp;amp;localIdentName=[path]__[name]__[local]__[hash:base64:5]&#39;],
      include: path.join(__dirname, &#39;css&#39;)
    }, {
      test: /\.(png|jpg|gif|svg)$/,
      loaders: [&#39;url?limit=8192&#39;],
      include: path.join(__dirname, &#39;image&#39;)
    }]
  }
}；
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;这样，不论是现有项目修改还是新项目从静态页面到react，都更为方便。&lt;/p&gt;

&lt;p&gt;最后修改在生产环境的webpack配置。&lt;/p&gt;

&lt;pre&gt;&lt;code class=&quot;language-js&quot;&gt;module.exports = {
  output: {
    path: path.join(__dirname, &#39;asset&#39;),
    filename: &#39;[name].[chunkhash].js&#39;,
    publicPath: &#39;/&#39;
  },
  resolve: {
    extensions: [&#39;&#39;, &#39;.js&#39;]
  },
  devtool: false,
  plugins: [
    new webpack.optimize.OccurenceOrderPlugin(),
    new webpack.DefinePlugin({
      &#39;process.env&#39;: {
        &#39;NODE_ENV&#39;: JSON.stringify(&#39;production&#39;)
      }
    }),
    new webpack.optimize.DedupePlugin(),
    new webpack.optimize.UglifyJsPlugin({
      compress: {
        warnings: false
      }
    }),
    new webpack.DefinePlugin({
      SITE_STATIC_PREFIX: JSON.stringify(SITE_STATIC_PREFIX),
      SITE_DYNAMIC_PREFIX:JSON.stringify(SITE_DYNAMIC_PREFIX)
    }),
    new ExtractTextPlugin(&#39;[name].[chunkhash].css&#39;, {allChunks:true}),
    new HtmlWebpackPlugin({
      template:&#39;scripts/index.ejs&#39;,
      minify:{
        removeComments: true,
        collapseWhitespace: true,
        removeRedundantAttributes: true,
        useShortDoctype: true,
        removeEmptyAttributes: true,
        removeStyleLinkTypeAttributes: true,
        keepClosingSlash: true,
        minifyJS: true,
        minifyCSS: true,
        minifyURL: true
      },
      inject:true
    })
  ],
  module: {
    loaders: [{test: /.jsx?$/,loaders: [&#39;babel&#39;],include: path.join(__dirname, &#39;scripts&#39;)}, {test: /.js?$/,loaders: [&#39;babel&#39;],include: path.join(__dirname, &#39;scripts&#39;)}, {test: /.css$/,loader: ExtractTextPlugin.extract(&#39;style&#39;, &#39;css?modules&amp;amp;importLoaders=1&amp;amp;localIdentName=[path]__[name]__[local]__[hash:base64:5]&#39;),include: path.join(__dirname, &#39;css&#39;)}, {test: /.(png|jpg|gif|svg)$/,loaders: [&#39;url?limit=8192&#39;, &#39;image-webpack?bypassOnDebug&amp;amp;optimizationLevel=7&amp;amp;interlaced=false&#39;],include: path.join(__dirname, &#39;image&#39;)}]
  }
};
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;其中尝试加入&lt;a href=&quot;https://github.com/tcoopman/image-webpack-loader&quot;&gt;图片压缩&lt;/a&gt;，但在windows环境下imagemin依赖的库会出现问题，目前没有解决方案，只能考虑在其他步骤中进行处理。&lt;/p&gt;

&lt;h1 id=&quot;section-2&quot;&gt;代码规范&lt;/h1&gt;
&lt;p&gt;按照以下进行了代码重写。
1. 重申命名规范，组件/页面单独文件夹，文件夹下index.js作为默认导出，使用到的多个组件在文件夹内创建[ComponentName.js]来引用。
2. 按照要求将react-router的hashHistory替换为browserHistory，在上面的修改完成后，由于使用browserHistory导致的资源路径问题也同步解决了。&lt;/p&gt;
</description>
        <pubDate>Mon, 11 Jul 2016 00:00:00 +0800</pubDate>
        <link>https://techctu.github.io//2016/07/11/%E5%89%8D%E7%AB%AF%E9%87%8D%E6%9E%84%E7%AC%AC%E4%B8%80%E6%AC%A1%E5%B0%9D%E8%AF%95.html</link>
        <guid isPermaLink="true">https://techctu.github.io//2016/07/11/%E5%89%8D%E7%AB%AF%E9%87%8D%E6%9E%84%E7%AC%AC%E4%B8%80%E6%AC%A1%E5%B0%9D%E8%AF%95.html</guid>
        
        <category>react</category>
        
        <category>webpack</category>
        
        
      </item>
    
  </channel>
</rss>
