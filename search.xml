<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title><![CDATA[首次 iOS Objective-C 开发记录]]></title>
    <url>%2F2018%2F06%2F11%2F%E9%A6%96%E6%AC%A1-iOS-Objective-C-%E5%BC%80%E5%8F%91%E8%AE%B0%E5%BD%95%2F</url>
    <content type="text"></content>
      <tags>
        <tag>iOS, Objective-C</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Java web application 使用 ziplet 来开启gzip压缩]]></title>
    <url>%2F2018%2F06%2F03%2FJava-web-application-%E4%BD%BF%E7%94%A8-ziplet-%E6%9D%A5%E5%BC%80%E5%90%AFgzip%E5%8E%8B%E7%BC%A9%2F</url>
    <content type="text"><![CDATA[目前除了 Spring 4 的 boot 和 Spring 5 里提供了相关应用层面的 Gzip 压缩，其他大部分时候都是通过容器（Tomcat、WAS、Jetty等）来开启 Gzip 压缩，剩下的都是 out of date 的自己写一个 filter 来实现这个功能。这里介绍一个开源的第三方库来实现这个功能。 加入依赖使用 maven 导入依赖。123456&lt;!-- https://mvnrepository.com/artifact/com.github.ziplet/ziplet --&gt;&lt;dependency&gt; &lt;groupId&gt;com.github.ziplet&lt;/groupId&gt; &lt;artifactId&gt;ziplet&lt;/artifactId&gt; &lt;version&gt;2.1.2&lt;/version&gt;&lt;/dependency&gt; 其他方式可以在 mvnrepository 找到。 增加 filter 配置在 web.xml 中增加配置。 12345678&lt;filter&gt; &lt;filter-name&gt;CompressingFilter&lt;/filter-name&gt; &lt;filter-class&gt;com.github.ziplet.filter.compression.CompressingFilter&lt;/filter-class&gt;&lt;/filter&gt;&lt;filter-mapping&gt; &lt;filter-name&gt;CompressingFilter&lt;/filter-name&gt; &lt;url-pattern&gt;/*&lt;/url-pattern&gt;&lt;/filter-mapping&gt; 配置项示例。12345678&lt;filter&gt; &lt;filter-name&gt;CompressingFilter&lt;/filter-name&gt; &lt;filter-class&gt;com.github.ziplet.filter.compression.CompressingFilter&lt;/filter-class&gt; &lt;init-param&gt; &lt;param-name&gt;debug&lt;/param-name&gt; &lt;param-value&gt;true&lt;/param-value&gt; &lt;/init-param&gt;&lt;/filter&gt; debug (optional): 是否输出 debug 信息，默认 false 。 compressionThreshold (optional): 设置开启压缩的最小 response 大小，单位 byte 。设置为 0 时永远开启压缩。默认 1024 。 statsEnabled (optional): 是否统计，详情见 CompressingFilterStats 。 includeContentTypes (optional): 设置针对某种 content type 开启压缩，如 text/html 。在 response 设置了 content type 之后调用。 excludeContentTypes (optional): include 和 exclude 是反义词，所以是设置排除某些 content type 的压缩。 includePathPatterns (optional): 类似 includeContentTypes ，不过是针对的 uri 。支持正则表达式，如 ‘.static.’ 。 excludePathPatterns (optional): 排除特定 uri 的压缩。 includeUserAgentPatterns (optional): 针对特定 UA 的压缩。 excludeUserAgentPatterns (optional): 排除特定 UA 的压缩。 noVaryHeaderPatterns (optional): 类似 includeUserAgentPatterns 。请求中符合配置的 UA 的响应不会包含 vary header 。 =&gt; github.com/ziplet]]></content>
      <tags>
        <tag>Java,gzip</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[React ES6+ 入门指引]]></title>
    <url>%2F2018%2F06%2F03%2FReact-ES6-%E5%85%A5%E9%97%A8%E6%8C%87%E5%BC%95%2F</url>
    <content type="text"><![CDATA[codepen 上的代码请 fork 后再修改。 环境基础 Chrome、FireFox等主流浏览器陆续支持 ES6+ 语法。 QQ、360、搜狗等浏览器已支持 ES6+ 语法。 微软全面转移到 Edge。 淘宝不再支持 IE 8 。 项目已使用 webpack、babel 等来提供转义支持。 简介 A JAVASCRIPT LIBRARY FOR BUILDING USER INTERFACES一个用于搭建用户界面的js库 核心思路：假定按照人机交互活动的不同状态来设计UI，根据状态的迁移来自动渲染页面。同时，react 通过组件化来分治状态。 Hello World123456789101112131415161718// 引入 js 类库import React from 'react'import ReactDOM from 'react-dom'// 定义 HelloWorld 组件class HelloWorld extends React.Component &#123; render() &#123; // return 中是 JSX 语法 return ( &lt;div&gt; Hello, world! &lt;/div&gt; ); &#125;&#125;// 找到 HTML 中的 id="root" 的标签，将 Hello 作为子元素插入ReactDOM.render(&lt;HelloWorld/&gt;, document.getElementById('root')); codepen ReactDOM.render()在客户端将 react 组件渲染成 HTML 的方法，在一般的 web app 中只在入口 js 文件中写一处。 JSX一种在 js 中书写 HTML 的简单方式，可以在其中通过 {} 来使用 js 表达式、变量、函数等。需要注意的是，由于 class 是 js 的关键字/保留字，所以 HTML 中的 class 需要写成 className 。简单语法如下。 1234567891011121314151617181920212223242526272829303132333435const generateJSX = (arg) =&gt; &#123; return &lt;h3&gt;&#123;arg&#125;&lt;/h3&gt;&#125;;class HelloWorld extends React.Component &#123; constructor(props) &#123; super(props) this.state = &#123; val: &#123;key: 'JSX中使用对象的值'&#125;, ifelse: '与其写那些匿名函数箭头函数，不如提出来写更好维护。' &#125;; &#125; render() &#123; return ( &lt;div&gt; &lt;h1&gt;JSX&lt;/h1&gt; &lt;h3&gt;&#123;this.state.val.key&#125;&lt;/h3&gt; &lt;h3&gt;&#123;true?'JSX中不能直接使用if-else，可以使用三元表达式':null&#125;&lt;/h3&gt; &#123;(function() &#123; if (true) &#123; return &lt;h3&gt;在JSX中使用立即执行的匿名函数来写if-else&lt;/h3&gt; &#125; &#125;)()&#125; &#123;true &amp;&amp; &lt;h3&gt;单if的时候可以用表达式&amp;&amp;jsx的方式来写&lt;/h3&gt;&#125; &#123;(() =&gt; &#123; if (true) return &lt;h3&gt;在JSX中使用立即执行的箭头函数来写if-else&lt;/h3&gt; &#125;)()&#125; &#123;generateJSX(this.state.ifelse)&#125; &lt;/div&gt; ); &#125;&#125;ReactDOM.render(&lt;HelloWorld/&gt;, document.getElementById('root')); codepen 需要注意的是，顶层只能有一对标签。 12345678910// badreturn &lt;div&gt;&lt;/div&gt; &lt;div&gt;&lt;/div&gt;// goodreturn &lt;div&gt; &lt;div&gt;&lt;/div&gt; &lt;/div&gt; 为什么要使用 JSX使用 JSX 时。123&lt;MyButton color="blue" shadowSize=&#123;2&#125;&gt; Click Me&lt;/MyButton&gt; 不使用 JSX 时。12345React.createElement( MyButton, &#123;color: 'blue', shadowSize: 2&#125;, 'Click Me') 就一般的 web 开发来说，显然第一种比较直观；对于不一般的 web 开发者来说，也还是第一种比较直观。 React 组件（Component）React 支持自定义组件，而组件化，是工程化的基础之一。React 支持自定义组件和传参（props）。将自定义组件类比 HTML 标签，参数就类似标签属性，能在 HTML 中怎么使用标签，就能在 JSX 中怎么使用组件。 定义组件一般由两种方式：函数和 es 6 class 。 函数方式：1234567function genComA(props=&#123;&#125;) &#123; return &lt;div&gt;hello&lt;/div&gt;&#125;const genComB = (props=&#123;&#125;) =&gt; &#123; return &lt;div&gt;hello&lt;/div&gt;&#125;; class：12345class Welcome extends React.Component &#123; render() &#123; return &lt;h1&gt;Hello, &#123;this.props.name&#125;&lt;/h1&gt;; &#125;&#125; 传参前面已经有过很多示例。 在 React 中，可以传递给组件的参数类型和 js 一致，包括 number、string、boolean、object、function 等。在组件中通过 this.props 获取接收到的参数。1234567891011121314151617class HiName extends React.Component &#123; render() &#123; return &lt;div&gt;Hi, &#123;this.props.name&#125;&lt;/div&gt; &#125;&#125;class HelloWorld extends React.Component &#123; render() &#123; return ( &lt;div&gt; &lt;HiName name=&#123;'sweetie'&#125;/&gt; &lt;/div&gt; ); &#125;&#125;// 输出 hi, sweetie 以函数形式创建的组件，则没有 this ，也就没有 this.props ，是通过封装成对象的形式传递，直接用 js 函数传参的方式获取即可。注：必须首字母大写，否则失效。12345678910111213function Bye(props) &#123; return &lt;div&gt;&#123;props.name&#125;, goodbye.&lt;/div&gt;&#125;class HelloWorld extends React.Component &#123; render() &#123; return ( &lt;div&gt; &lt;Bye name=&#123;'sweetie'&#125;/&gt; &lt;/div&gt; ); &#125;&#125; this.props.childrenReact 中有个保留的参数，叫 this.props.children ，主要用于封装和动态加载子组件。常见的用法有单页面 web app 中 header 和 footer 固定，内部内容动态变化等。12345678910111213class App extends Component &#123; render() &#123; return ( &lt;div&gt; &lt;Header /&gt; &lt;div&gt; &#123;this.props.children&#125; &lt;/div&gt; &lt;Footer /&gt; &lt;/div&gt; ) &#125;&#125; 参数校验React 支持参数校验，包括 js 的数据类型、自定义类型、非空、枚举等。1234567891011class Greeting extends React.Component &#123; render() &#123; return ( &lt;h1&gt;Hello, &#123;this.props.name&#125;&lt;/h1&gt; ); &#125;&#125;Greeting.propTypes = &#123; name: React.PropTypes.string&#125;; 具体参考官网。 状态（state）React 组件基于自身的 state 变化来触发 render ，并进行相应的计算，达到渲染的效果。所以 state 的使用，是 React 中最重要的部分。 React 组件的生命周期节点为 mount -&gt; (update) -&gt; unmount 。 其中 mount 和 unmount 在生命周期中只执行一次，update 执行 0 到多次。 mount 和 update 都会触发 render 。 对于 mount 和 update 都有 will 和 did 两种处理函数，对于 unmount 只有 componentWillUnmount。 提供 shouldComponentUpdate 来处理比较复杂的情况下组件 state 变化是否渲染，以提升性能。紧急逃生，慎用。 提供 componentWillReceiveProps 用于组件 mount 之后接收参数再次更新 state 。 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123class PropsCount extends React.Component &#123; componentWillMount() &#123; console.log('PropsCount will mount') &#125; componentDidMount() &#123; console.log('PropsCount did mount') &#125; componentWillUpdate(nextProps, nextState) &#123; console.log('PropsCount will update') &#125; componentDidUpdate(prevProps, provState) &#123; console.log('PropsCount did update') &#125; render() &#123; console.log('PropsCount render') return &lt;div&gt;count update by props: &#123;this.props.count&#125;&lt;/div&gt; &#125;&#125;class StateCount extends React.Component &#123; constructor(props) &#123; super(props); this.state = &#123;count: props.count&#125;; &#125; componentWillMount() &#123; console.log('StateCount will mount') &#125; componentDidMount() &#123; console.log('StateCount did mount') &#125; componentWillUpdate(nextProps, nextState) &#123; console.log('StateCount will update') &#125; componentDidUpdate(prevProps, provState) &#123; console.log('StateCount did update') &#125; componentWillReceiveProps(nextProps) &#123; this.setState(&#123;count: nextProps.count&#125;); &#125; render() &#123; console.log('StateCount render') return &lt;div&gt;count update by state: &#123;this.state.count&#125;&lt;/div&gt; &#125;&#125;class Init extends React.Component &#123; constructor(props) &#123; super(props); this.state = &#123;count: props.count&#125; &#125; componentWillMount() &#123; console.log('Init will mount') &#125; componentDidMount() &#123; console.log('Init did mount') &#125; componentWillUpdate(nextProps, nextState) &#123; console.log('Init will update') &#125; componentDidUpdate(prevProps, provState) &#123; console.log('Init did update') &#125; render() &#123; console.log('Init render') return &lt;div&gt;init: &#123;this.state.count&#125;&lt;/div&gt; &#125;&#125;class HelloWorld extends React.Component &#123; addOne = () =&gt; &#123; this.setState(&#123;count: this.state.count + 1&#125;); &#125;; constructor(props) &#123; super(props); this.state = &#123;count: 0&#125;; &#125; componentWillMount() &#123; console.log('HelloWorld will mount') &#125; componentDidMount() &#123; console.log('HelloWorld did mount') &#125; componentWillUpdate(nextProps, nextState) &#123; console.log('HelloWorld will update') &#125; componentDidUpdate(prevProps, provState) &#123; console.log('HelloWorld did update') &#125; render() &#123; console.log('HelloWorld render') return ( &lt;div&gt; &lt;Init count=&#123;this.state.count&#125; /&gt; &lt;button value="addOne" onClick=&#123;this.addOne&#125;&gt;add&lt;/button&gt; &lt;PropsCount count=&#123;this.state.count&#125; /&gt; &lt;StateCount count=&#123;this.state.count&#125; /&gt; &lt;/div&gt; ); &#125;&#125;ReactDOM.render(&lt;HelloWorld/&gt;, document.getElementById('root')); codepen 注意：在 componentWillMount componentWillUpdate 中不要使用 setState。初始化的异步请求最好放在 componentDidMount 里，其他初始化的同步操作放在 constructor 里。 处理事件和获取值官网参考。123456789101112131415161718class A extends React.Component &#123; constructor (props) &#123; super(props) this.state=&#123;name:null&#125; &#125; onChange = (e) =&gt; &#123; this.setState(&#123;name: e.target.value&#125;) &#125;; render () &#123; return &lt;div&gt; &lt;input type="text" onChange=&#123;this.onChange&#125; /&gt; &lt;br /&gt; &#123;this.state.name &amp;&amp; &lt;label&gt;hi, &#123;this.state.name&#125;&lt;/label&gt;&#125; &lt;/div&gt;; &#125;&#125; codepen]]></content>
      <tags>
        <tag>ReactJs,react</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[非潮流前端项目架构-Java和ReactJS]]></title>
    <url>%2F2018%2F06%2F03%2F%E9%9D%9E%E6%BD%AE%E6%B5%81%E5%89%8D%E7%AB%AF%E9%A1%B9%E7%9B%AE%E6%9E%B6%E6%9E%84-Java%E5%92%8CReactJS%2F</url>
    <content type="text"><![CDATA[项目特征 运行于第三方 APP 内，需要以 H5 等相关后台技术为基础。 UE 、 UI 、静态页面由合作公司开发，然后再套用到前端项目中。 页面较少，但需要在第三方 APP 内进行多次 webview 切换，路由需要自己负责，第三方 APP 不提供支持。 动静分离。 前端前端技术采用 React 、Webpack 、 Babel 等，开发时热更新。 没有 redux ，没有 RxJS ，没有 SEO 。 Web api 采用 Spring ，部署于 WAS 。 后端较重，使用 Dubbo 等。 组织架构前端的工作流程如图。面临的问题主要有： UE 设计缺乏设计规范和支撑实施设计规范的组件库，经常会出现分支流程缺失的情况。比如某个流程失败，某几个展示要素缺失等。 UE 设计的缺失导致 UI 没有对此进行设计，因此静态页面也缺少相关实现。比如一个物品最多可以展示 5 个标签，只实现了展示 5 个标签和不展示标签。 反馈流程过长，许多上述问题在开发阶段和测试阶段才暴露出来。 组件化受限于静态页面开发质量，影响组件化的实施。 模板套用因为项目组内缺乏对 css 、 less 、 scss 、 postcss 等熟悉的工程师，所以从 UI 到静态页面是从外部公司采购的。我们拿到的静态页面是这样的。1234567- app|-- css| | |-- app.css|-- image|-- html| | |-- pageA.html| | |-- pageB.html 拿到之后，将静态资源复制到对应的目录下，然后将 html 的内容改写成 jsx 。很多页面展示内容和业务强相关，可以共用的组件基本就是 header ， modal ， toastr ，存储和路由等。 代码组织前端代码采用动静分离，分为两个部分：页面代码和 web api 。 页面代码组织Java 项目的工程化是非常成熟的，页面代码参考 Java 项目，该分层的分层，该配置管理的配置管理。 按照页面划分路由，每个页面保存自己的 state ，全局变量使用 localStorage 来传递。 由于存在 webview 切换的问题，没有使用 redux 等，当然也可以考虑切换前利用 localStorage 持久化，切换后用其初始化。 12345678910111213141516171819202122232425262728293031323334- app|-- asset // 构建输出目录|-- css // 样式源文件目录|-- image // 图片源文件目录|-- node_modules // npm 仓库|-- scripts // js源文件目录| | |-- pages // 相当于一般 react 项目中的 container| | | | |-- [Page] // 页面目录| | | | | | |-- index.js // 入口文件| | | | | | |-- [Component].js // 页面组件文件，0 到多个| | |-- routes // 封装页面为 react-router lazy-load 组件| | | | |-- [Page] // 对应页面目录| | | | | | |-- index.js // 页面 route 配置文件| | |-- utils // 公共库| | | | |-- polyfill // 适配第三方 APP 的代码| | | | |-- [CommonComponet] // 公共 react 组件目录，如 Toastr| | | | |-- Example // 示例代码目录| | | | |-- global.js // 基础公共函数库| | | | |-- browserHistory.js // history.js + react-router| | | | |-- clientStorage.js // 使用 cookie / storage 本地存储| | |-- app.js // 客户端 js 入口| | |-- index.ejs // 生成入口 html 的模板文件|-- tools // 构建相关源文件目录| | |-- clean.js // 清理历史构建文件| | |-- zip.js // 构建输出打包| | |-- copy.js // 管理外资源拷贝，如 favicon.js| | |-- start.js // 开发用 web server，基于 webpack-dev-server| | |-- verify.js // 验证构建结果的 web-server| | |-- ...|-- .babelrc // 目前配置在 package.json 里|-- .eslint // 代码规范校验|-- .eslintIgnore // 忽略代码规范校验|-- package.json // npm 描述文件|-- webpack.config.[target].js // 对应各个环境的 webpack 配置。 页面构建项目主要通过 webpack 构建静态资源。webpack 的构建以配置文件中的 entry 为起点，对依赖的资源进行静态分析，然后通过 loaders 和 plugins 进行处理，输出到 output。 构建时的性能优化： 通过 CommonsChunkPlugin 抽取公共函数库，打包成单独的 js chunk 。 通过 UglifyJsPlugin 压缩 js 。 通过 css-loader 压缩 css 。 通过 url-loader 将小图片转为 base64 ，减少小文件请求。 通过 webpack 提供的 import 和 react-router 配合使用，实现延迟加载的功能，进一步提升首屏加载速度，保证各个页面的加载速度。 Additional： 在 pre-build 阶段，提供清理之前构建，复制依赖之外的资源等功能的脚本。 在 post-build 阶段，提供输出目录压缩，启动模拟目标部署环境 web server 验证等功能的脚本。 web api 代码组织web api 是典型的 maven web project 。 12345678910- project|-- src| | |-- main| | | | |-- java // java 源文件| | | | |-- portable // 构建时的部署环境配置| | | | |-- resources // 各种依赖配置，如 spring，dubbo ， redis ， shiro ， logback ， shiro 等。| | | | |-- webapp| | | | | | |-- web.xml // 主要是 web.xml 的配置。| | |-- test // 对应同级 java 目录的单元测试文件|-- pom.xml // maven 描述文件，项目对象模型 Java 里充当 express/koajs 等角色的实际上是 web 容器，Spring 对应的是 express/koajs 生态圈的一揽子方案，包括了 route 、 template 、load 等等。 web api 构建所有的项目构建其实内容都差不多：预处理 -&gt; 处理 -&gt; 后处理 -&gt; 输出。maven 就等于是 Java web 的 npm + webpack 。npm install, webpack -&gt; maven install 。 运行态此时前台访问一个页面的过程大致上如图。 静态资源服务器使用 nginx ，没有做同构直出。为了正确渲染页面，任意请求返回的都是同一个 index.html （try_files），该 index.html 含有 app.css ，外壳 + 路由配置的 app.js 。app.js 加载完成后，则会进一步 lazy-load 对应 uri 所需的 js 文件。 因此，初次访问或者缓存过期的情况下，一个页面的访问有： 请求 index.html 。 请求 app.css 。 请求 app.js 。 请求 vendor.js 。 请求 [route].js 。 请求其他静态资源，如静态图片资源。 其他动态请求。 而 app.css 、 app.js 、vendor.js 在缓存后如果是 304 ，并不会再次请求。 TBC less/scss/postcss 。 后端渲染。 RN 。 koa&amp;pm2 。]]></content>
      <tags>
        <tag>react,ReactJs,Java,Spring</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[10分钟搞定 react 二维码、条码生成组件]]></title>
    <url>%2F2018%2F06%2F03%2F10%E5%88%86%E9%92%9F%E6%90%9E%E5%AE%9A-react-%E4%BA%8C%E7%BB%B4%E7%A0%81%E3%80%81%E6%9D%A1%E7%A0%81%E7%94%9F%E6%88%90%E7%BB%84%E4%BB%B6%2F</url>
    <content type="text"><![CDATA[条码生成首先去万能的 npm 上找到一个库安装。 npm install jsbarcode --save 然后写一个简单的 react 组件。需要转换成条码的原始字符串来源可能有很多，我们在这里就弄个输入框好了。 输入 =&gt; 转换 =&gt; SVG条形码 1234567891011121314151617181920212223242526272829303132import React from 'react';import JsBarcode from 'jsbarcode';class CodePainterExample extends React.Component &#123; constructor(props) &#123; super(props); &#125; render() &#123; return ( &lt;div&gt; &lt;input type="text" placeholder="请输入原始字符串" onChange=&#123;(e)=&gt;&#123; // 在 this._barcodeSVG 下使用输入的数值来生成条码 JsBarcode(this._barcodeSVG, e.target.value, &#123; displayValue: false, // 不显示原始值 background: '#4b8b7f', // 背景色 lineColor: 'rgba(255,255,255,0.5)', // 线条颜色 width: 1 // 线条宽度 &#125; ); &#125;&#125;/&gt; &lt;br/&gt; &lt;label&gt;条码&lt;/label&gt;&lt;br/&gt; &lt;svg ref=&#123;(ref)=&gt;this._barcodeSVG = ref&#125;&gt;&lt;/svg&gt; &lt;/div&gt; ); &#125;&#125;export default CodePainterExample; 二维码生成一样在 npm 找到库 qr-image 安装。npm install --save qr-image 同样，在上面的例子里加一个新的 svg 标签，来放我们的二维码。由于这个库主要是用在 nodejs 中，我们使用其中提供的 svgObject.path 来绘制二维码。 1234567891011121314151617181920212223242526import svgpath from 'svgpath';import qr from 'qr-image';class CodePainterExample extends React.Component &#123; constructor(props) &#123; super(props); this.state = &#123; path: null // 保存二维码SVG的path &#125;; &#125; render() &#123; return ( &lt;div&gt; &lt;input type="text" placeholder="请输入" onChange=&#123;(e)=&gt;&#123; const originPath = qr.svgObject(e.target.value).path; // 获得二维码的绘制路径 this.setState(&#123;path: originPath&#125;); &#125;&#125;/&gt; &lt;br/&gt; &lt;label&gt;二维码&lt;/label&gt;&lt;br/&gt; &lt;svg width="100%" height="300" ref=&#123;(ref)=&gt;this._qrcodeSVG = ref&#125; transform="scale(2)"&gt; &lt;path d=&#123;this.state.path?this.state.path:null&#125;/&gt; &lt;/svg&gt; &lt;/div&gt; ); &#125;&#125; 这样生成的二维码图形意外的小，还得找个库来放大一下我们的二维码。npm install --save svgpath然后，试着放大一下我们的二维码。 12const scaledPath = svgpath(originPath).scale(5, 5).toString();this.setState(&#123;path: scaledPath&#125;); 完美。​]]></content>
      <tags>
        <tag>react,qrcode,barcode</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[从 Jekyll 到 Hexo，GitHub 到 VSTS，自动构建博客发布]]></title>
    <url>%2F2018%2F06%2F01%2F%E4%BB%8E-Jekyll-%E5%88%B0-Hexo%2F</url>
    <content type="text"><![CDATA[手贱又买了个域名，还用的自己姓名拼音，儿童节快乐。 再次搭建博客的缘由 知乎专栏太杂，一点都不 geek，我想写 markdown。 简书传播性不好，也很杂。 GitHub 太小气了，私有仓库要付钱，我要把源文件私有，把生成的博客发布，还是不用 Jekyll 直接在公共仓库放 Markdown 了。 Jekyll highlight 语法再见！ VSTS 大法好，私有仓库免费，微软黑转粉。 强迫症，博客原文一定要私有，提交完就自动构建并发布到 GitHub Pages，虽然 hexo deploy 很方便，但我不想用。 编写 -&gt; 本地预览 -&gt; 上传 VSTS -&gt; 自动构建 -&gt; 发布到 GitHub Pages 。 VSTS 构建，GitHub 发布首先，需要一个 VSTS 账号，免费申请。 然后，用 VSTS 作为自己博客的仓库，创建构建任务，参考使用VSTS/TFS搭建iOS持续集成环境。 在构建任务里，在 hexo 生成好的文件夹（默认 public）内，push 到 GitHub。 123456789npm installgit initgit config --global user.name $(github_name)git config --global user.email $(github_email)git pull https://$(github_token)@github.com/***/***.github.io.git masterhexo generategit add -Agit commit -m "$(build.buildNumber)"git push -f https://$(github_token)@github.com/***/***.github.io.git head:master push 到 VSTS 后，立刻自动构建发布，完美。 参考资料 在 GitHub Pages 搭建个人博客 在 Godaddy 购买域名 用 CloudFlare 给自己的 GitHub Pages 博客挂上 https Hexo Jekyll 从 Jekyll 到 Hexo 使用 Next GitHub 和 VSTS 双向同步源代码 使用VSTS/TFS搭建iOS持续集成环境]]></content>
      <tags>
        <tag>Jekyll,Hexo,Godaddy,GitHub Pages</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[webpack 2 和 react-router 实现按需加载]]></title>
    <url>%2F2017%2F02%2F24%2Fwebpack-2-%E5%92%8C-react-router-%E5%AE%9E%E7%8E%B0%E6%8C%89%E9%9C%80%E5%8A%A0%E8%BD%BD%2F</url>
    <content type="text"><![CDATA[产品上线了一段时日，偷偷摸摸把 webpack 升级到了 2.x ，出现了很多优化需求，意味着很多新的库、新的代码，以及，更大的 bundle 。怎么办呢？ Code Splitting 呗！按需加载、懒加载┏ (゜ω゜)=☞。 Code Splitting 的方式前端代码一般需要进行拆分的地方有： 公共代码拆分，如所有代码共用的三方库，某些业务模块或页面用的三方库。 特定业务场景加速，如首页，或者多页面入口时的入口页面加速。比如现在老板要你做个地理位置的AR，总不能直接把这个包和常规业务代码丢一块加载吧。 babel 、 webpack 依赖配置很多人都说 ES6 、 ES7 会毁了 JavaScript ，但各大语言语法趋向一致不是大趋势吗？难道之前的人开发写了一堆 polyfill 来解决各种诡异的问题后纷纷走向高级岗位，还要像吹牛逼说自己拿记事本写上万行代码一样，要求后来者也会写这堆 polyfill 吗？使用成熟的工具，是团队成功的必要条件之一吧。新的版本的曙光已经到来，不必抱残守缺。 基础配置这里使用的 webpack 为 2.2.1 。按照 webpack 官网文档，需要先安装 babel 相关插件。 npm install --save-dev babel-core babel-loader babel-plugin-syntax-dynamic-import babel-preset-es2015 然后在 .babelrc 里，或是在 package.json 的 &quot;babel&quot; 里，亦或在 webpack.config 的 module -&gt; rules -&gt; use -&gt; loader: &#39;babel-loader&#39; 的同级下配置。这里我是在 package.json 里配置。 123456&#123; "babel": &#123; "presets": ["es2015"], "plugins": ["syntax-dynamic-import"] &#125;&#125; 这样就可以这样写代码。 12345678function determineDate() &#123; import('moment') .then(moment =&gt; moment().format('LLLL')) .then(str =&gt; console.log(str)) .catch(err =&gt; console.log('Failed to load moment', err));&#125;determineDate(); 目前这样已经可以使用 webpack 和 babel 来进行代码拆分了。 尝鲜配置目前 ES7 的 async/await 语法都要出来了，只配置这些怎么够？所以我这样配置。 npm install --save-dev babel-preset-es2015 babel-preset-es2016 babel-preset-2017 babel-preset-stage-0 babel-plugin-transform-decorators babel-plugin-transform-decorators-legacy babel-plugin-transform-object-rest-spread babel-preset-react 123456&#123; "babel": &#123; "presets": ["es2015","es2016","es2017","stage-0","react"], "plugins": ["syntax-dynamic-import","transform-decorators-legacy","transform-object-rest-spread"] &#125;&#125; 然后就可以用各种新特性，比如箭头函数、async/await、装饰器等。 基于 react-router 的代码拆分在 react-router的示例代码 huge-apps 里有非常经典的基于路由的代码拆分方案。 为什么基于路由拆分？一般一个路由对应一个逻辑上的业务页面，而一般多个业务页面在一个子路由下构成了业务流程，其代码依赖也比较相近，适合做代码拆分。 基础路由配置不拆分的路由长 这样 。 12345678&lt;Router&gt; &lt;Route path="/" component=&#123;App&#125;&gt; &lt;Route path="about" component=&#123;About&#125; /&gt; &lt;Route path="inbox" component=&#123;Inbox&#125;&gt; &lt;Route path="messages/:id" component=&#123;Message&#125; /&gt; &lt;/Route&gt; &lt;/Route&gt;&lt;/Router&gt; 或者 这样 。 12345678910111213141516171819202122const routes = &#123; path: '/', component: App, indexRoute: &#123; component: Dashboard &#125;, childRoutes: [ &#123; path: 'about', component: About &#125;, &#123; path: 'inbox', component: Inbox, childRoutes: [&#123; path: 'messages/:id', onEnter: (&#123; params &#125;, replace) =&gt; replace(`/messages/$&#123;params.id&#125;`) &#125;] &#125;, &#123; component: Inbox, childRoutes: [&#123; path: 'messages/:id', component: Message &#125;] &#125; ]&#125; 然后，构建时 webpack 就会把所以依赖静态分析后打到指定的 bundle 里。 路由拆分配置react-router 利用 webpack 支持的 require.ensure 来实现延迟加载。基本思路是将需要拆分的路由注册到路由配置里，将依赖的 react 组件通过 require.ensure 来加载，听过 getChildRoutes 和 getComponents 这样的黑科技。 12345678910111213141516171819202122232425262728293031323334353637383940414243// 组件和其路由// Announcement/Announcement.jsimport React from 'react'class Announcement extends React.Component &#123; render() &#123; let &#123; courseId, announcementId &#125; = this.props.params let &#123; title, body &#125; = COURSES[courseId].announcements[announcementId] return ( &lt;div&gt; &lt;h4&gt;&#123;title&#125;&lt;/h4&gt; &lt;p&gt;&#123;body&#125;&lt;/p&gt; &lt;/div&gt; ) &#125;&#125;module.exports = Announcement// 对应路由封装和暴露// Announcement/index.jsmodule.exports = &#123; path: ':announcementId', getComponent(location, cb) &#123; require.ensure([], (require) =&gt; &#123; cb(null, require('./components/Announcement')) &#125;) &#125;&#125;// 路由配置const rootRoute = &#123; component: 'div', childRoutes: [ &#123; path: '/', component: require('./components/App'), childRoutes: [ require('./routes/Announcement') ] &#125; ]&#125; 简单来说，就是 123456789101112131415161718const rootRoute = &#123; component: 'div', childRoutes: [ &#123; path: '/', component: require('./components/App'), childRoutes: [ &#123; path: ':announcementId', getComponent(location, cb) &#123; require.ensure([], (require) =&gt; &#123; cb(null, require('./components/Announcement')) &#125;) &#125; &#125; ] &#125; ]&#125; webpack 2.x 下的加载方式上面是 webpack 1.x 的配置方式，而在 2.x 下，需要进行一些修改，主要是用 import 替换 require.ensure 。 12345678910111213// Announcement/index.jsmodule.exports = &#123; path: ':announcementId', getComponent(location, cb) &#123; import('./components/Announcement') .then((module)=&gt;&#123;cb(null, module.default);&#125;) .catch((err)=&gt;&#123;console.log(err)&#125;); // require.ensure([], (require) =&gt; &#123; // cb(null, require('./components/Announcement')) // &#125;) &#125;&#125; TODOs 懒加载划分和加载异常处理。 合适的目录结构划分。]]></content>
      <tags>
        <tag>webpack</tag>
        <tag>react-router</tag>
        <tag>babel</tag>
        <tag>webpack2</tag>
        <tag>延迟加载</tag>
        <tag>按需加载</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[在 html 中使用 react 和 jsx —— 不使用 nodejs]]></title>
    <url>%2F2017%2F02%2F18%2F%E5%9C%A8-html-%E4%B8%AD%E4%BD%BF%E7%94%A8-react-%E5%92%8C-jsx--%E4%B8%8D%E4%BD%BF%E7%94%A8-nodejs%2F</url>
    <content type="text"><![CDATA[今天有人跟我提了一个非常奇怪的需求：想使用 reactjs 来组件化，重写以前封装的组件。但他们的 leader 又觉得 node 、 npm 、 webpack 那一套很麻烦，太复杂了，只想要 react 封装组件。所以他想要的可能是这样： 组件封装在 js 里，使用 react 封装。 访问某个页面时，返回对应的 html 文件，文件中引入 js ，非 SPA 。 绝对不使用 node 、 npm 、 webpack 。 Try。 在 html 中使用 react可以参考 Getting Started with React （不能访问请翻墙）。 开始使用 react去国内 CDN 去找到 react 、 react-dom 、 browser 三个库，如 BootCDN 。 参考一下官网的 hello-world 。 找个地方创建目录，写一个 index.html 。 123456789101112131415161718192021222324252627&lt;!DOCTYPE html&gt;&lt;html lang="zh-cmn-Hans"&gt; &lt;head&gt; &lt;title&gt;My First React Example&lt;/title&gt; &lt;/head&gt; &lt;body&gt; &lt;div id="greeting-div"&gt;&lt;/div&gt; &lt;script src="http://cdn.bootcss.com/react/15.4.2/react.js"&gt;&lt;/script&gt; &lt;script src="http://cdn.bootcss.com/react/15.4.2/react-dom.js"&gt;&lt;/script&gt; &lt;script src="http://cdn.bootcss.com/babel-core/6.1.19/browser.js"&gt;&lt;/script&gt; &lt;script type="text/babel"&gt; var Greeting = React.createClass(&#123; render: function() &#123; return ( &lt;p&gt;Hello, Universe&lt;/p&gt; ) &#125; &#125;); ReactDOM.render( &lt;Greeting/&gt;, document.getElementById('greeting-div') ); &lt;/script&gt; &lt;/body&gt;&lt;/html&gt; 这段代码创建了一个名为 Greeting 的 react 组件，然后在 greeting-div 这个 div 下使用 react-dom 的 render 方法来渲染成如下代码： 123&lt;div id="greeting-div"&gt; &lt;p&gt;Hello, Universe&lt;/p&gt;&lt;/div&gt; 原文其他部分不再翻译，毕竟这篇文章不是为了翻译，只是记录一下怎么在浏览器中使用 react 。语法部分的问题参考其他文章即可 与使用 webpack 等的区别在一般的开发过程中，使用的是 node + npm + webpack + babel + react + react-dom ， 可能还要使用 redux 系列的库来开发，项目多为 SPA 。从开发到浏览器访问的处理过程一般为： 1react 组件/页面（ es6 语法）--（ webpack 、 babel ）--&gt; es5 语法的 js chunk 如果不使用这些，辣么就得在浏览器中通过 browser.js 来将 es6 的语法转换成 es5 。 这样做很有可能会降低页面渲染速度。 对最终目录结构的猜想可能是类似这样： 1234567891011/|__view| |__home| | |__index.html // 页面入口html| | |__index.js // 页面入口js| | |__ComA.js // 页面使用的组件|__common|__|__header|__|__footer // 在这里的 html 模板片段中引入 react 、 react-dom 和 browser|__css // 可能 css 就是一个文件|__image]]></content>
      <tags>
        <tag>react</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[使用 nodejs zip / tar 目录 / 文件夹]]></title>
    <url>%2F2017%2F02%2F18%2F%E4%BD%BF%E7%94%A8-nodejs-zip--tar-%E7%9B%AE%E5%BD%95--%E6%96%87%E4%BB%B6%E5%A4%B9%2F</url>
    <content type="text"><![CDATA[有某个大佬想要搞自动发布，问我能不能搞一个 zip 静态资源目录的脚本。我瞅了瞅他，看在 windows 环境的面子上，就没有要求他自己写 shell 脚本了。 去 npm 找一个库万能的 npm 上有个 archiver ，正好可以打包目录，和那些只能 appendFile 的妖艳贱货都不一样呢。 写打包脚本 你会写nodejs吗？我也不知道什么算会写啊，写个这个脚本打包个目录算不算？ 直接上代码： 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657import fs from 'fs';import archiver from 'archiver';import moment from 'moment';// 使用 nodejs 封装的接口检查是否存在输出目录function checkOutputDir(dest='archiver/') &#123; return new Promise((resolve, reject) =&gt; &#123; // nodejs版本更新后将fs.R_OK挪到了fs.constants.R_OK const R_OK = fs.R_OK || fs.constants.R_OK; const W_OK = fs.W_OK || fs.constants.W_OK; fs.access(dest, R_OK | W_OK , (err)=&gt;&#123; if (err) &#123; console.log('try to create archiver directory'); fs.mkdir(dest, function(err)&#123; if (err) &#123; console.error('fail: create archiver directory'); reject(err); &#125; resolve(); &#125;); resolve(); &#125; else &#123; console.log(`can read and write $&#123;dest&#125;`); resolve(); &#125; &#125;); &#125;);&#125;// 压缩资源async function zip(targetEnv='production', src='asset/', dest='archiver/', project='projName') &#123; await checkOutputDir(); await new Promise((resolve, reject) =&gt; &#123; const file = `$&#123;dest&#125;$&#123;project&#125;-$&#123;targetEnv&#125;-$&#123;moment().format('YYYYMMDD-HHmmss')&#125;.zip`; console.log(`prepare to create zipped file: $&#123;file&#125;`); let archive = archiver('zip', &#123;zlib:&#123;level: 9&#125;&#125;); let out = fs.createWriteStream(file); out.on('close', function()&#123; console.log(archive.pointer() + ' total bytes'); console.log('archiver finalized'); &#125;); archive.on('error', (err)=&gt;&#123;reject(err);&#125;); archive.directory(src); archive.pipe(out); archive.finalize(); resolve(); &#125;);&#125;export default zip; TODOs干脆用command整个命令得了。]]></content>
      <tags>
        <tag>nodejs</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[从 webpack 1.x 迁移到 webpack 2.x]]></title>
    <url>%2F2017%2F02%2F18%2F%E4%BB%8E-webpack-1x-%E8%BF%81%E7%A7%BB%E5%88%B0-webpack-2x%2F</url>
    <content type="text"><![CDATA[项目搭建使用的 webpack 1.3.1 来作为打包工具，webpack 2.2 已经发布。 升级项目依赖备份，在 package.json 中移除 webpack 依赖。使用了 extract-text-webpack-plugin 的话这个插件也需要更新。 修改 webpack.config （开发）debug1.x 中使用了 debug:true 的配置，在 2.x 中改为： plugins: [ new webpack.LoaderOptionsPlugin({debug: true}) ] resolveresolve.extensions 不再需要传入空字符串，extensions: [&#39;&#39;, &#39;js&#39;] -&gt; extensions: [&#39;js&#39;]。 增加 modules 配置来加速加载 modules: [path.resolve(__dirname, &#39;./scripts&#39;), &#39;node_modules&#39;] 。 proxy因为动静分离，1.x 中使用了 proxy:{&#39;/uri/*&#39;:{target:&#39;https://host&#39;}} 来进行代理。在 2.x 中将这部分配置挪到了启动 webpack-dev-server 的脚本中： 1234567891011new WebpackDevServer(bundler, &#123; proxy: &#123; '/yh-web/*': &#123; //target: 'http://localhost:9080' target: 'http://10.230.146.19:9080' &#125;, '/yx-web/*': &#123; target: 'http://localhost:9090' &#125; &#125;&#125;) NoErrorsPlugin废弃，使用 NoEmitOnErrorsPlugin 。 modulemodule.loaders 修改为 module.rules 。 Loaders 需要添加 -loader，如 babel -&gt; babel-loader 。 修改生产配置 webpack.config.production.js除了上述修改，目前主要为 extract-text-webpack-plugin 的配置修改。 extract-text-webpack-plugin Plugin 中的参数 new ExtractTextPlugin(&#39;css/[name].[chunkhash].css&#39;, {allChunks: true}) 修改为 new ExtractTextPlugin({filename: &#39;css/[name].[chunkhash].css&#39;, allChunks: true} rules 中 css 抽取修改为 use: ExtractTextPlugin.extract({fallback: &#39;style-loader&#39;, use: &#39;css-loader?modules&amp;minimize&amp;importLoaders=1&amp;localIdentName=[hash:base64:5]&#39;}) OccurenceOrderPlugin 和 DedupePlugin废弃，webpack 2.x 自带，不再使用。 UglifyJsPlugin官方默认配置已修改，这里配置改为 12345new webpack.optimize.UglifyJsPlugin(&#123; compress: &#123;warnings: false&#125;, souceMap: false, minimize: true&#125;) 参考Migrating from v1 to v2 从 webpack v1 迁移到 webpack v2 webpack 2终极优化]]></content>
      <tags>
        <tag>webpack</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[停止更新，使用issues来记录]]></title>
    <url>%2F2017%2F02%2F04%2F%E5%81%9C%E6%AD%A2%E6%9B%B4%E6%96%B0%E4%BD%BF%E7%94%A8issues%E6%9D%A5%E8%AE%B0%E5%BD%95%2F</url>
    <content type="text"><![CDATA[最后一篇，以后使用 issues 来记录。 有空了再挑挑文章来迁移。]]></content>
  </entry>
  <entry>
    <title><![CDATA[使用GSAP简单实现react列表中的下拉刷新和上拉加载更多]]></title>
    <url>%2F2017%2F01%2F11%2F%E4%BD%BF%E7%94%A8gsap%E7%AE%80%E5%8D%95%E5%AE%9E%E7%8E%B0react%E5%88%97%E8%A1%A8%E4%B8%AD%E7%9A%84%E4%B8%8B%E6%8B%89%E5%88%B7%E6%96%B0%E5%92%8C%E4%B8%8A%E6%8B%89%E5%8A%A0%E8%BD%BD%E6%9B%B4%E5%A4%9A%2F</url>
    <content type="text"><![CDATA[项目上线后看着列表不能下拉刷新不能上拉加载非常不爽，就做了个简单的实现。 为什么自己造轮子？用react不想添加jQuery，同时GitHub上的大部分代码都不能同时支持上拉和下拉。 准备找个现成的项目新建一个页面，写个timeout模拟异步请求。1234567891011refresh() &#123; setTimeout(()=&gt;&#123;this.setState(&#123; items: [1,2,3,4,5] &#125;)&#125;, 1000);&#125;loadMore() &#123; setTimeout(()=&gt;&#123;this.setState(&#123; items: this.state.items.concat([1,2,3,4,5]) &#125;)&#125;, 1000);&#125; 再整个生成列表。 123456789101112function renderList(list) &#123; return (list.map((v, i) =&gt; ( &lt;li key=&#123;i&#125; onClick=&#123;function() &#123;browserHistory.push('/MerchantDetail/' + v.id + '/' + v.distance);&#125;&#125;&gt; &lt;div styleName="m-shop-right"&gt; &lt;h1&gt; &#123;i&#125; &lt;/h1&gt; &lt;/div&gt; &lt;/li&gt;) ) );&#125; 然后开始搞事情。 实现下拉和上拉设计现在的上拉和下拉大部分是： 监听ontouchstart, ontouchmove, ontouchend三个事件。 判断上拉下拉边界，进行对应的CSS transform和transition。 12345// sample，监听list的事件，修改list-header&lt;div id="list"&gt; &lt;div id="list-header" /&gt; &lt;div id="list-items" /&gt;&lt;/div&gt; 实现最开始想用 react-css-transition-group 或 react-transition-group 来实现上拉和下拉效果，像这样： 1234&lt;reactcsstransitiongroup ref=&#123;(el) =&gt; this._ref = el&#125;&gt; &lt;div id="list-header" /&gt; &lt;div id="list-items" /&gt;&lt;/reactcsstransitiongroup&gt; 然而仔细阅读了之后，发现只能在 mount 和 unmount 这两个关键点触发动画，在 update 的时候无法触发。 我非常不希望通过 style123456789这个就非常微妙了，既然如此，我为何一定要用 `react-css-transition-group` 或 `react-transition-group` 呢？简单点不好么？直接把这部分动画操作放在直接的DOM操作里绕开react，然后在ontouchend里回调，也是一种不错的思路。```js&lt;div id=&quot;g-wrap&quot; onTouchStart=&#123;(e) =&gt; this.handleTouchStart(e)&#125; onTouchMove=&#123;(e) =&gt; this.handleTouchMove(e)&#125; onTouchEnd=&#123;(e) =&gt; this.handleTouchEnd(e)&#125;&gt; // ...&lt;/div&gt; 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768handleTouchStart(e) &#123; this._touchStartPosY = e.touches[0].pageY;//记录触摸开始位置 this._gmainDefaultPaddingTopRem = '1.8rem';//记录初始列表头部位置，可改成接收参数 this._gmainDefaultPaddingTop = parseInt( this._gmainDefaultPaddingTopRem.substr(0, this._gmainDefaultPaddingTopRem.length - 3)); this._gmainDefaultPaddingBottom = 0;//底部 this._lastScrollY = -1;//用于记录上一次滚动位置 this._equalScroll = false;//用于标记上拉到了底部&#125;handleTouchMove(e) &#123; this._touchEndPosY = e.touches[0].pageY; // 下拉到顶 if (window.scrollY &lt;= 0) &#123; this._lastScrollY = window.scrollY; // 拉且限制拉的距离 if (this._touchEndPosY - this._touchStartPosY &gt; 0 &amp;&amp; this._touchEndPosY - this._touchStartPosY &lt; 100) &#123; let gmain = findDOMNode(this._gmain); // 偷懒使用TweenMax来生成动画 TweenMax.to(gmain, 0, &#123;paddingTop: this._gmainDefaultPaddingTop + (this._touchEndPosY - this._touchStartPosY)/20 + 'rem', ease: Power0.easeInOut&#125;); &#125; &#125; else &#123; // 上拉到底 if (window.scrollY == this._lastScrollY) &#123; if (!this._equalScroll) &#123; this._equalScroll = true; this._equalScrollY = window.scrollY; this._equalClientY = e.touches[0].clientY; &#125; let gmain = findDOMNode(this._gmain); e.preventDefault(); // 限制上拉距离生成动画 let offsetY = this._touchEndPosY&gt;100?100:this._touchEndPosY; TweenMax.to(gmain, 0, &#123;paddingBottom: this._gmainDefaultPaddingBottom + offsetY/20&gt; + 'rem', ease: Power0.easeInOut&#125;); &#125; else &#123; this._lastScrollY = window.scrollY; &#125; &#125;&#125;handleTouchEnd(e) &#123; if (window.scrollY &lt;= 0) &#123; if (this._touchEndPosY - this._touchStartPosY &gt; 0) &#123; let gmain = findDOMNode(this._gmain); // 弹回 TweenMax.to(gmain, 1, &#123;paddingTop: this._gmainDefaultPaddingTopRem, ease: Back.easeInOut&#125;); this.refresh(); &#125; &#125; else &#123; if (this._equalScroll) &#123; let gmain = findDOMNode(this._gmain); // 弹回 TweenMax.to(gmain, 1, &#123;paddingBottom: this._gmainDefaultPaddingBottom, ease: Power3.easeInOut&#125;); this.loadMore(); &#125; &#125;&#125; 总结整个思路就是：通过起始 pageY 和结束 pageY 判断用户垂直滑动方向，在根据 window.scrollY 和保存的上一次滑动位置来判断是否到顶（或者到底），到顶（或者到底）后执行 tansform，touchEnd的时候进行回调。 当然这只是个简单实践，还需要进一步优化，比如： 支持传入回调函数。 支持定义限制的上拉下拉高度。 支持上拉下拉时载入自定义的静态资源，如活动动画或是刷新效果等。 设置默认参数。 将TweenMax改为原生方法实现减少大小。 抽取为high-order-component。 最近这种纯前端的东西做的有点多，是时候拿 nodejs 和 express/koa 搞事情了。]]></content>
      <tags>
        <tag>react</tag>
        <tag>gsap</tag>
        <tag>pull to refresh</tag>
        <tag>push to load more</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[在Babel6中使用ES7 Decorator]]></title>
    <url>%2F2017%2F01%2F10%2F%E5%9C%A8babel6%E4%B8%AD%E4%BD%BF%E7%94%A8es7-decorator%2F</url>
    <content type="text"><![CDATA[在做下拉的时候搜寻到的资料。 增加decorator支持假设你已经安装过 babel-preset-2015 和 babel-preset-react 等，并配置完毕。 npm install --save-dev babel-plugin-transform-decorators-legacy 然后在 .babelrc 中添加： 123&#123; "plugins": ["transform-decorators-legacy"]&#125; 或者在webpack配置文件中： 1234567891011121314module: &#123; loaders: [ &#123; test: /\.js$/, exclude: /node_modules\/(?!(stardust))/, loader: 'babel', query: &#123; plugins: [ 'transform-decorators-legacy', ] &#125;, &#125; ]&#125; 使用方式在我项目代码中使用了react-css-modules。原来是这样的： 123456789import CSSModules from 'react-css-modules';import styles from 'app.css';import &#123;Component&#125; from 'react'class A extends Component &#123;&#125;export default CSSModules(A, styles, &#123;allowMultiple: true&#125;); 使用之后是这样的： 12345678910import CSSModules from 'react-css-modules';import styles from 'app.css';import &#123;Component&#125; from 'react'@CSSModules(styles, &#123;allowMultiple: true&#125;)class A extends Component &#123;&#125;export default A; 总结为什么要用decorator？在实现下拉的时候，我就在想，如果能在实现一个动画效果后，能应用到任意组件上就好了，所以才找到了decorator。 参考： -Structuring React Applications: Higher-Order Components -Reusing ReactTransitionGroup animations with Higher-order Components]]></content>
      <tags>
        <tag>babel</tag>
        <tag>decorator</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[2016年年终总结]]></title>
    <url>%2F2016%2F12%2F17%2F2016%E5%B9%B4%E5%B9%B4%E7%BB%88%E6%80%BB%E7%BB%93%2F</url>
    <content type="text"><![CDATA[一年一度的年终总结又开始了，前几年的年终总结要么拖着拖着就没写了，要么就是写了忘了放哪了。今年把之前的博客从国外的托管主机上的WordPress博客放到了github上，然后用七牛去做了一下镜像缓存，码字和发布的体验提升了不少，也就有了那么一点写年终总结的兴致。 今年整个部门最重要的工作就是三大平台的建设，年初我参与了部分WLAN建设工作，之后的主要工作是负责其中一个子中心的前端建设工作。 前端建设 我是我行一块砖，哪有需要往哪搬。 履历背景最开始的时候，其实我是做后端的。这里的后端是我们部门成立的时候用Spring、Zookeeper、Dubbo、Quartz等搭建的架构。2013年那时候P2P特别火，我负责的是P2P投资流程的设计和开发。那时候的感触就是，数据库设计中一定的冗余是必要的，范式不一定合适；外系统的东西一定要在接口层隔离；日志要清晰，生产环境不允许debug。 14年的时候部门重构了系统，对各个子项目进行了拆分，这个时候就体现出了设计模式原则的重要性。之前我们就要求尽可能隔离外部系统、外部接口对内部的影响，所以重构的时候基本没有对现有项目产生大的影响。 后来就去做了几个新业务的APP开发，接触了一个非常魔幻的开发框架，是这个公司提供的。该框架是在Objective-C和Java上包了一个lua解释器，使用lua来进行开发。那阵子主要负责跟业务谈需求，然后再用Axure画UE，再盯开发实现和UE、UI有什么差距。 2015年的时候主要是做APP，使用那个魔幻框架，深切感受到了开发工具的重要性。没有高亮、没有自动格式化、没有错误提示、没有自动补全，这样的开发体验非常不友好，极大降低了开发效率，一些设计上的原则和规范也很难顺利执行。 Q:为什么使用这个框架？A:（假装没听见这个问题） 年底研究了支付宝、微信支付等接口，在这个魔幻框架上实现了第三方APP和浏览器调起客户端支付的功能。 2016年初主要是参与一个WLAN建设的项目，毕竟我行网点众多，像这种在一般小饭馆提供WiFi服务的项目，规模上去了，就会出现很多问题。 之后，就是建设子中心前端了。 第一版前端第一版前端如果从立项开始计算，经历了7个月。从成果上看，是一个APP的四个主页面中的一个页面及其后续流程。对于互联网公司来说，太慢了；但对于我行来说，这是一个了不起的成就了。毕竟，12月开始讨论需求，讨论到了3月底，还要改UE原型。原计划是5月上线，最后推到了6月。 第一版碰到了许多坑，可能有很多我都忘了，得好好想想。这是我接触前端技术的开始，也是接触工程化开始思维侧重点向工程化偏移的开始。 刚开始的时候，大佬说用react吧，Facebook的react很火啊很火啊，我们一堆萌新狂点头好呀好呀你是大佬你说什么都是对的，然后就上了react。DEMO，或者说流行的叫法为starter-kit，迅速搭建了起来，一切看起来很美好。 舍弃AmazeUI大佬们说，工期紧啊，用react框架吧！然后找了一个画风看起来小清新的啊妹子UI。 当时的AmazeUI，组件难用，耦合高，使用起来感觉很重，代码质量也不高，而且不方便根据我们的需求进行定制。当然当时react还年轻，各个框架也不成熟，包括阿里的Ant-Design。不是说不好，但这些框架比较适合的还是作为中后台的管理系统前端框架，不适合我们进行定制开发。而且页面可以服用的部分不多，不需要过度追求组件化。 于是乎，我们就把啊妹子UI舍弃了。 后期啊妹子UI好像招到了一个比较牛的人，整个画风都不一样了。 全站HTTPS放公网测试的时候，发生了一件非常尴尬的事情。运营商真是非常牛逼的，一言不合就往你的页面塞广告。这我能怎么办呢？没办法，全站HTTPS吧。 地理位置定位一般浏览器中使用的为IP定位和window.navigator.geolocation来获取经纬度定位。IP定位不准，geolocation定位受限于浏览器（webview）内核，如果用户刷机，甚至可能无法连接定位服务（被墙你懂的）。 那么，使用百度地图JS API吧！然后换全站HTTPS之后，百度地图JS API出现各种问题。 高德没有试过，有机会可以试试。 还好有万能的第三方APP提供他们的定位接口，才能解决这个定位问题。 第三方APP内的路由这又是个神奇的问题。在第三方APP里，你是要调用APP提供的接口来登录和支付的。调用登录和支付，会切换webview，导致原生的history返回出错。同时，第三方给的入口页面有第三方自己的header和footer，进入二级页面也会切换webview。 只能自己记录一个栈，实现自己的返回方法了。简单来说就是在本地记录一个访问栈，每次访问新页面的时候把地址压入栈，返回的时候出栈。第一版使用的是Cookie，在react-router的onEnter方法中注入，避免路由影响页面部分的开发。 这个方法存在一定的问题，难以记录当前页面状态，如多个页面的表单填写，需要保存当前表单的填写字段时，或是一个列表做了筛选操作时，需要做一定的特殊处理；需要清理Cookie；Cookie在会带入请求增加请求大小等。 开发部署流程改进初始的starter-kit中，虽然在webpack的配置文件里配置了css-loader、style-loader、url-loader来处理样式、图片等资源，但在实际使用过程中，只在入口html文件里引入了样式文件 &lt;link src=&quot;app.css&quot;&gt; ，并没有考虑css、图片的压缩、优化等处理。为了将css、图片等资源纳入管理，使用了inline css方式，将css、图片也像js一样引入进来，并使用loader来处理，编写了示例代码，修改了文件输出方式增加了哈希值。 因为我厂采用的是采购外部厂商设计UI实现静态页面，我们利用静态页面来开发的合作方式，引入了react-css-modules来处理样式，避免编写内联样式，优化开发体验。 小结 产品上线使用，初步搭建了前端开发部署框架和规范化的流程。 存在一些优化方面的问题。 路由全部由前端控制，使用的hashHistory，没有后端渲染。没有自动化测试。 没有执行Eslint。 第二版前端第二版前端主要在第一版基础上进行了一些改造。 替换为browserHistory #后面应该是锚点，url应该就是/，为什么路由要用#？2016年了还#，你这是搞事情！ 代码洁癖：保持和最广泛的规范一致，不要搞事情。 修改点： 前后端的uri前缀配置。 页面跳转方式使用browserHistory.push。 修改打包时各种静态资源的相对路径注入方式。 修改跨页面变量存储方式封装了Cookie和localStorage，自动判断本地是否支持localStorage，优先使用localStorage；如果强制要求使用Cookie则使用Cookie。 抽取第三方APP相关的接口代码将路由、登录、支付代码从页面代码和内部公共代码部分抽离，以备后期代码复用时配置化管理。 部署配置纳入管理最近投产发生了替换静态资源后大面积出现404的问题，原因是之前应该投产的配置文件修改由于种种原因没有投产，导致出错。现将配置文件纳入管理。 团队建设严格来说，技术团队的建设谈不上特别复杂，相对来说比较单纯——你技术强大家就会听你的。只不过在我们的开发中技术团队的构成比较复杂一点： 成员构成为我、入职新人、厂商的驻场开发人员。 前端开发由另外的厂商提供静态页面，再由上述三类开发人员开发。 按照“看山”的分法，大部分的开发人员停留在“看山是山”的程度，并不了解隐藏在背后的思量。作为前端建设的负责人，我不可能也不应该完成前端的大部分编码，而是要挑选适合的人选进行培养，然后在保证质量的前提上，提高团队工作的效率，减少bug率，提高整个团队的水准。 实际上，我并没有特地对人员进行培养，只是提供了不少参考文档和示例代码，布置了一些开发任务，然后期待他们的主观能动性。如何培养人才？这方面一直是我欠缺的，希望来年在这方面多下功夫。]]></content>
      <tags>
        <tag>年终总结</tag>
        <tag>其他</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[x-www-form-urlencoded、json和@RequestParam、@RequestBody]]></title>
    <url>%2F2016%2F12%2F07%2Fx-www-form-urlencoded%E5%92%8Cjson%2F</url>
    <content type="text"><![CDATA[临近下班碰到新人有个bug找不到原因，症状是发送了ajax请求后后台收不到数据。经过跟踪，发现请求头为 123456Accept:*/*Accept-Encoding:gzip, deflate, brAccept-Language:zh-CN,zh;q=0.8,ja;q=0.6,en-US;q=0.4,en;q=0.2,zh-TW;q=0.2Connection:keep-aliveContent-Length:112Content-Type:application/json 而后台使用Spring-MVC。Controller中的获取报文方式为@RequestParam。这是导致无法接受到参数的原因。 @RequestParam和@RequestBody@RequestParam为Spring提供的注解，对应处理String类型的body参数，如 a=1&amp;b=2 这类。 @RequestBody同为Spring提供的注解，对应处理非String类型的body参数，如json。 以上需要在Spring里进行配置。]]></content>
      <tags>
        <tag>Context-Type</tag>
        <tag>HTTP</tag>
        <tag>Java</tag>
        <tag>Spring</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[在iOS APP内部使用JS访问webview时uri的查询参数需要encode两次]]></title>
    <url>%2F2016%2F11%2F08%2F%E5%9C%A8ios-app%E5%86%85%E9%83%A8%E4%BD%BF%E7%94%A8js%E8%AE%BF%E9%97%AEwebview%E6%97%B6uri%E7%9A%84%E6%9F%A5%E8%AF%A2%E5%8F%82%E6%95%B0%E9%9C%80%E8%A6%81encode%E4%B8%A4%E6%AC%A1%2F</url>
    <content type="text"><![CDATA[背景最近在使用开发运行于第三方APP内的SPA时，需要打开浏览器访问百度地图。APP提供了一个 [prefix-to-open-browser]/[url-to-visit] 的格式，可以在webview内使用 window.location.href = &#39;[prefix-to-open-browser]/[url-to-visit]&#39; 的方法来打开浏览器。 问题使用 [prefix-to-open-browser]/https://www.baidu.com 时没有问题，但uri中包含中文参数时，使用 encodeURI([uri]) 无法打开浏览器。 跟踪在浏览器中进行测试，encodeURI 确实能将uri中的字符串进行编码： encodeURI之前：https://www.baidu.com/s?wd=编码encodeURI之后：https://www.baidu.com/s?wd=%E7%BC%96%E7%A0%81 而在APP内部获取到的却是 https://www.baidu.com/s?wd=编码，导致APP无法打开浏览器。 解决最后在浏览器中发现，encodeURI之后，在浏览器中访问时，会自动decodeURI一次。在使用两次encodeURI之后，就解决了这个问题。]]></content>
      <tags>
        <tag>iOS</tag>
        <tag>webview</tag>
        <tag>javascript</tag>
        <tag>js</tag>
        <tag>uri</tag>
        <tag>encode</tag>
        <tag>encodeURI</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[为什么使用react/使用react有什么好处？]]></title>
    <url>%2F2016%2F10%2F10%2F%E4%B8%BA%E4%BB%80%E4%B9%88%E4%BD%BF%E7%94%A8react%E4%BD%BF%E7%94%A8react%E6%9C%89%E4%BB%80%E4%B9%88%E5%A5%BD%E5%A4%84%2F</url>
    <content type="text"><![CDATA[接手前端后，摸着石头过河，采用推荐的新的react框架，踩过不少坑，终于项目平稳上线。随之而来就会有许多人问： 为什么要使用react？react有什么好处？和jQuery/velocity/bootstrap/AngularJS/Vue.js相比有什么优点？其中我只用过jQuery+velocity，用过一点bootstrap，AngularJS和Vue.js都是道听途说，没有真正接触，不敢妄加评论，只能从自身经历，提供一点浅见。 问题的本质这个问题的应该需求分析一下： 使用react开发H5页面复杂吗？对新人的学习曲线怎么样？开发是否方便快捷？调试是否方便？ react能解决哪些方面的问题？不能解决哪些方面的问题？还需要什么补充？ 好像没有3了。 React和现在使用的相关技术首先，重申一点，react是一个UI框架，更正确的说法，应该只是提供了构建自己的UI框架的底层库。举个栗子，蚂蚁金服的ant design和啊妹子UI，都可以说是基于react构建的UI框架，包含了大家熟悉的按钮、轮播图、单选按钮组等组件。 而前端的客户端部分，也是存在MVC，或者流行的MV*结构的。所以，react肯定是需要其他方面技术补充的。 为什么不直接使用ant design/Amaze UI？ 我们构建的是面客系统，会有自己的设计风格，而使用ant design或是其他框架，其框架太重，不适合按照我们的特殊需求进行定制。这类框架比较适合内部系统或者是管理系统使用。 由于React只是一个底层库，所以react需要一些其他的技术来构建SPA（单页面应用），如：依赖管理和打包的webpack、前端路由react-router、状态管理flux/redux/reflux等。 下面从我的经验介绍一下React及其系列相关技术的优缺点。 React开发的优点React的开发其实是一件非常简单的事情。React的开发除了一个由于保留字需要把HTML的 class 替换成 className，剩下的就是专注于使用流程和状态来控制页面（JavaScript），以及将状态对应到正确的样式上（JSX）。 简单，封装如果使用过jQuery的第三方组件，或者bootstrap等，一旦页面比较复杂，就会碰到重命名、选择器等问题；如果使用过AngularJS，或者一些其他模板引擎，一定会学习这些库特有的一些语法，或是标签，如： 123456// AngularJS的循环遍历&lt;ul&gt; &lt;li *ngFor="#hero of heroes"&gt; &#123;&#123;hero.name&#125;&#125; &lt;/li&gt;&lt;/ul&gt; 而在react里，你只需要会HTML和JavaScript。什么是jsx？ 这是html： 1&lt;div style="background-color: #fff;"&gt;这是HTML&lt;/div&gt; 这是JavaScript（ECMAScript 2015/ES6）： 12345class SomeClass &#123; functionA() &#123; return null; &#125;&#125; 这是JSX： 12345678910111213141516171819202122232425let myDivElement = &lt;div className="foo" /&gt;;ReactDOM.render(myDivElement, document.getElementById('example'));// 更高级一点，自定义组件class MyComponent extends React.Component &#123; // 面向对象中眼熟的继承 constructor(props) &#123; // react封装的自定义组件的参数传递方式 this.state = &#123; hello: this.props.hello &#125;; &#125; // react的组件渲染方法 render() &#123; return( &lt;div&gt; &lt;label&gt;自定义react组件&lt;/label&gt;&lt;lable&gt;&#123;this.state.hello&#125;&lt;/lable&gt; &lt;/div&gt;) &#125;&#125;let hello = 'world';let myDivElement = &lt;MyComponent hello=&#123;hello&#125;/&gt;; // 给自定义组件传参ReactDOM.render(myDivElement, document.getElementById('example')); JSX很简单，就是在js中使用HTML标签组成的HTML片段，没有奇怪的属性，标签，方法，没有奇怪的属性，标签，方法，没有奇怪的属性，标签，方法，我喜欢的特性说三遍。 所以，react的核心思想就是，让开发人员关注业务流程变化导致的状态变化，将状态对应到具体的页面展示上，而对DOM的操作，交给react来进行。这样的方式，非常适用于目前由第三方出静态页面，我们的开发人员来实现最终效果的分工方式。 强大的开发工具在Java开发的时候，我们已经习惯了代码高亮、自动补全、语法提示、源码定位、规范检查、压缩混淆打包等功能，react开发自然也是有这一系列工具的，涵盖了Sublime、Atom、VSCode等多种编辑器，还具有在Chrome、Firefox进行调试的插件。 虽然经常有人吹牛说能用记事本写出千行代码，然而那只是个人能力，总不能要求所有人都具备这种能力，所以有好用的工具为何不用呢？自动化工具的使用，才利于项目的工程化，提高项目组整体的实施水平，极大提高开发效率，甚至一个好的代码高亮主题还能吸引妹子在你身后围观你编码。 UNIX哲学专注于解决一个问题，小而精，而非大而全。 尤其是在我们目前使用SpringMVC处理动态请求，使用nginx处理静态请求的架构下；具有自己的UE和UI设计的条件下，那些大而全的现有框架的一些隐蔽的使用条件，如某些库所需的支持等，和按照设计对一些内容进行改造等，非常繁琐不便利。 React提供了一个完整的UI渲染更新流程，设计了一个组件封装的生命周期。使用react，将DOM操作交给react，能使开发人员专注于业务流程，减少繁琐的DOM操作的开发，降低由于DOM操作导致的bug（在使用jQuery的年代很常见，bootstrap也是，很多以HTML为设计核心的难以封装模板引擎也是）。 使用小而精的工具，能使我们对手中的项目了若指掌，避免莫名的问题。 丰富的库支持21465 results for ‘react’. 社区和文档支持等React具有比较详细的文档、教学视频和大量的示例代码、脚手架，在某知名大型国际同性交友网站上能找到10W+相关代码。 React开发的缺点大致说完了优点，来说说缺点。 JavaScript发展快速，导致了混乱这几年是JavaScript，嗯，ECMAScript发展迅速的一年，前端相关们都各有各的野心，浏览器厂商和标准组织合纵连横，谷歌微软苹果互相掐架，微软Mozilla眉来眼去，两年就从ES5到了ES6眼看着又要马不停蹄奔向ES7了，这就导致目前百度搜索到的react示例大部分使用ES5，一部分使用ES6，少量使用ES7，不利于初学者学习，尤其是大部分人都是从学习写blog写到阿里的某大牛开始。 而我们，使用的是ES6。 注：JavaScript是ECMA-262标准的实现和扩展，我们使用的ES6基于ECMA-262 6th Edition。 太多工具既然要拥抱UNIX哲学，那么就会面临大量工具选择的问题：编辑器、构建、脚手架、规则校验、测试等，都需要进行选择、配置，以便项目组进行开发。 虽然我写了一些工具配置使用说明，但不知为何很多人还是使用一个没有安装任何插件的Sublime/Atom进行开发，难道都是记事本写十万行不出bug的大牛？ React设计思想React和相关系列技术的设计思想，是开发人员使用react的最大门槛。 React的willMount-didMount-willReceiveProps-shouldUpdate-willUpdate-didUpdate-willUnmount的生命周期，规范了DOM的更新，同时也提高了学习门槛。开发人员需要了解何时重写生命周期方法，这就要求开发人员对页面可能发生的状态迁移和目标结果有充分了解。事实上，我觉得，开发人员也应该清楚页面的状态迁移和目标结果——至少是大部分的。 同时，react支持多种创建组件的方式：React.createClass、ES6 Classes和stateless functional components（无状态组件）。 应该使用哪个方式？开发人员会面临混乱。 React官方指出应该分为两层：使用无状态组件渲染页面各个部分；使用ES6 Classes保持页面状态；React.createClass是ES5及其之前的东西，请勿使用——恰巧这是目前国内大部分示例使用的方式。 同时目前由于页面不是很复杂所以没有采用的各大状态管理机制，也暂时降低了开发难度。 从开发的支持筛选、搜索的商户列表页来看，似乎马上也要使用flux/redux/reflux一类了，蓝瘦，香菇。 语言障碍目前国内大部分示例停留在ES5，已过期，需要翻墙去寻找示例。 总结在项目从2015年底需求研究开始到2016年4月开始一个月开发一个月测试投产上线，再到10月的二期期间，经历了接触react、webpack、ES6、react-router等到利用空档偷偷摸摸重构项目、修改目录结构、修改代码编写范例、利用非工作时间充电等，对这一系列技术有了一定的了解。 总的来说，react的使用和大部分技术一样，在一个团队里，只需要一个技术比较好的人搭建了boilerplate，写了几个sample，其他人依样画葫芦就可以了。而项目质量，从来不是一门语言、一个库或者框架就能决定的。]]></content>
      <tags>
        <tag>react</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[react-router：从hashHistory到browserHistory]]></title>
    <url>%2F2016%2F07%2F31%2Freact-router%E4%BB%8Ehashhistory%E5%88%B0browserhistory%2F</url>
    <content type="text"><![CDATA[项目开始使用react-router时由于工期原因，使用了hashHistory，在url末尾会形成/#/user/haishanh?_k=adseis中_k=adseis的query字符串。这在浏览器中打开时会让用户感到迷惑。 hashHistory和queryKey在一些旧的浏览器中，不支持H5提供的新的接口如pushState，则使用了该方法生成key来读写window.sessionStorage的内容，实现页面跳转和回退时保持页面状态的功能，如类似新浪微博列表页请求了几次更多微博，进入详情页面后返回到列表页之前获取的微博仍然在里面无需重复之前的请求；又或者一个流程多个复杂表格填写，在前进、后退过程中保持之前填写的内容。 在【react-router】hashhistory 与 browserhistory有什么区别中有简单设置以去掉_k=abc123。 12345678910import &#123; createHashHistory &#125; from 'history';const appHistory = useRouterHistory(createHashHistory)(&#123; queryKey: false &#125;);ReactDOM.render( &lt;Router history=&#123;appHistory&#125;&gt; &#123;routes&#125; &lt;/Router&gt;, document.getElementById('app')); 问题：无法使用state保持页面状态，无法使用state来渲染链接对应页面，如 12345const path = &#123; pathname: 'business/BaiduSearch/update', state: &#123; id: record.id &#125;&#125;&lt;Link to=&#123;path&#125;&gt;修改&lt;/Link&gt; 使用browserHistory在一些框架、库提供的糖面前，我倾向于不使用改变更广泛的标准的做法。如上面通过使用hashHistory和queryKey来获取state来渲染页面的方法，我更倾向于使用http://example.com/the/path?the=query&amp;id=recordId的方式获取相关信息渲染页面，这样在分享链接时也更为方便。 创建browserHistory本来可以直接使用react-router提供的browserHistory，但考虑到该项目对应的域名为xxx.xxx.com/xx，而且本地开发环境使用localhost:port访问，所以引入history。 123456789101112import &#123;createHistory&#125; from 'history'import &#123; Router, Route, useRouterHistory&#125;const browserHistory = useRouterHistory(createHistory)(&#123;basename: process.env.NODE_ENV === 'production'? '/xx': ''&#125;)const routes = ( &lt;Router history=&#123;browserHistory&#125;&gt; ... &lt;/Router&gt;) 同时，需要修改对应的web容器配置，使其知道/xx/下的所有uri路由到单页面应用。目前使用的nginx。 123location /xx/ &#123; try_files $uri /xx/index.html;&#125; state目前state的作用主要是提供了保持页面状态的功能，包括相关的存取功能。这部分功能可以使用很多方式实现，如history的location.state，cookie，甚至是引入redux等。]]></content>
      <tags>
        <tag>react</tag>
        <tag>react-router</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[前端重构第一次尝试后思路整理]]></title>
    <url>%2F2016%2F07%2F14%2F%E5%89%8D%E7%AB%AF%E9%87%8D%E6%9E%84%E7%AC%AC%E4%B8%80%E6%AC%A1%E5%B0%9D%E8%AF%95%E5%90%8E%E6%80%9D%E8%B7%AF%E6%95%B4%E7%90%86%2F</url>
    <content type="text"><![CDATA[最近做了一个项目的前端开发，上线了，然而怎么看都是一个玩具一般的东西，需要一次强力升级。前段时间也看了很多博客，翻了很多文档，对项目进行了一次小小的外科手术，但随着了解深入，收获的知识越来越多，接触到的问题也越来越多。道高一尺魔高一丈，也许也能这样解释？得整理一下思路，降服一下心魔了。 目前项目状态初始状态： 参考之前jQuery + Velocity年代，目录分为css、scripts、img，scripts下分为pages和util。 项目较小，为嵌入APP webview中的H5项目，css放入一个统一的css文件中。 引入react、react-router。 使用webpack打包，只输出bundle.js到asset目录下，bundle.js和css文件直接在index.html中引用。 图片和css样式在react组件中直接以className=&quot;class-a class-b&quot;和&lt;img src=&quot;../../img/a/png&quot; /&gt;的方式使用。 一个这样的项目，怎么就这样上线了？除了在生产打包使用了webpack.optimize.UglifyJsPlugin这种打包压缩js之外，看不到现代前端工程的痕迹。虽然是个小项目，可以不那么重视性能，但连gzip都没有开是怎么回事？一个400多k的bundle.js在webview中请求并加载运行的速度完全不能接受。而且这个项目可能要作为模板在其他项目中使用。作为一个有代码和工程洁癖的人，怎么能忍受这样的事情？ 然后有了之前的进阶修改。 此时，了解的知识和碰到的问题越来越多，如前端性能优化最佳实践，某技术总监的前端博文等；也发现了不少帮助解决前端工程问题的工具，如fis3@Baidu-FEX-team，yo@Google-Yeoman-team。已经有不少前辈趟过雷踩过坑，很多文章都很精彩，但并不一定适合我所在team的环境。也许，需要针对我厂特点进行一个定制了。 需求分析现有环境： 苛刻的资源权限管理：生产环境、代码资源、测试环境、外网环境等申请困难重重。 内网环境开发和部署，可以支持代理上npm。 代码版本管理可能使用TFS/SVN/Git等多种版本管理工具，目前使用TFS。 前端开发人员前端开发技能熟练度不高，对JQuery系不很熟练的程度，更不用说es6、react、组件化。 打包部署流程有待考察。 不一定适用CDN，目标运行环境主要为移动设备，包括手机、平板、笔记本。 目前为粗暴缩放，缺乏精细多屏适配设计与实现。 需求： 开发规范：基于es6、react、webpack开发，要有开发规范，快速定位开发问题，提高开发效率。 模块化/组件化：有自己的模块/组件仓库，解决命名空间、组件独立、依赖管理、按需加载执行、安全合并等问题，区分开业务相关和业务无关的模块和组件。 react技术：使用react作为UI组件，使用react-router管理前端路由，使用redux管理前端状态，状态数据结构必须immutable。 性能优化：通过工程化方法进行性能优化，包括加速首屏加载，图片压缩合并，CSS Sprite，Base64图片，缓存和缓存更新，性能提升统计评估等。 项目部署：开发资源组织规则和部署资源组织规则分离，支持动静分离、静态资源缓存、CDN、非覆盖式发布等。 开发流程：内网环境开发，支持通过代理访问外网npm，代码托管在内网windows server TFS上，构建也位于windows server，可以通过代理访问外网npm，生产构建位于windows。 开发工具：内网开发，编辑器、IDE、构建与优化工具、开发-调试-部署等流程工具，以及组件库获取、提交等相关工具，甚至运营、文档、配置发布等平台工具。 协作流程：业务提交需求，厂商提供UEUI和静态页面，组内开发人员根据静态页面编写react页面。 后台：目前使用Java SpringMVC，动态请求发送POST到Controller，Service层使用Dubbo。 其他：待发掘。 分析： 对于第1点，前期的改造基本完成。 第2、3点需要修改目录结构，提供samples。 第4点目前已经使用了缓存、hash、gzip压缩、base64等技术，Java环境下的react首页直出有待研究。 第5、6点和本厂大环境相关，只考虑开发和打包过程，从代码仓库抽取到打包环境和打包环境到生产部署的过程和工具暂不考虑。 第7点已经编写了内网环境下搭建基于sublime的开发环境的教程。 第8点主要在于本组静态页面开发能力较弱，需要长期培养。 第9点主要用于考虑后期使用node替换SpringMVC使web前后端同构，java只负责服务层。 所以目前主要考虑的应该是，静态资源开发和组织的工程化，在进阶修改的基础上引入redux及其相关技术，进一步组件化，构建自己的组件仓库，提供samples等。可以先研究yeoman这样的构造工具。国内fis3这样的工具不像yeoman这样透明直观，使用时对其机理存疑。]]></content>
      <tags>
        <tag>webpack</tag>
        <tag>react</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[前端重构第一次尝试]]></title>
    <url>%2F2016%2F07%2F11%2F%E5%89%8D%E7%AB%AF%E9%87%8D%E6%9E%84%E7%AC%AC%E4%B8%80%E6%AC%A1%E5%B0%9D%E8%AF%95%2F</url>
    <content type="text"><![CDATA[前段时间自行吐槽了自己参与大部分工作的前端项目，慢慢学习前端工作流到现在，并尝试了重构，记录一下。 配置管理首先，把和环境相关的配置提取出来，使用webpack.DefinePlugin，避免每次部署时开发环境、测试环境、生产环境的变量手动修改。123456789101112/* 定义运行环境相关变量 */var SITE_STATIC_PREFIX = '/yh-wifi-web/';/* ... */module.exports = &#123; plugins: [ new webpack.DefinePlugin(&#123; SITE_STATIC_PREFIX: JSON.stringify(SITE_STATIC_PREFIX), SITE_DYNAMIC_PREFIX:JSON.stringify(SITE_DYNAMIC_PREFIX) &#125;) ]&#125;； 资源管理然后，把css和图片等资源文件从在index.html里直接饮用挪到js中引用，以便将静态资源文件纳入管理，解决热部署问题（大公司里怎样开发和部署前端代码？ - 回答作者: 张云龙）。 123/* 引用静态资源 */import zoneMomImage from '../../../image/mom.png';import styles from '../../../css/app.css'; 在webpack配置中添加对应loader。 1234567891011121314/* 在webpack配置中添加对应loader */module.exports = &#123; module: &#123; loaders: [&#123; test: /\.css$/, loader: loaders: ['style?sourceMap', 'css?modules&amp;camelCase&amp;sourceMap'], include: path.join(__dirname, 'css') &#125;, &#123; test: /\.(png|jpg|gif|svg)$/, loaders: ['url?limit=8192'], include: path.join(__dirname, 'image') &#125;] &#125;&#125;； 这样，就可以在react中使用css module。 123.sample-camel&#123; color: red;&#125; 在react中引用之后，可以使用对应变量表示样式 123render( return &lt;div className=&#123;styles.sampleCamel&#125; /&gt;) 然而，考虑到现在的前端开发流程，UE-&gt;UI-&gt;HTML+CSS-&gt;react组件，以及现有项目的修改难度，引入了react-css-modules。 12345678910111213141516171819202122// ComponentSample.jsimport CSSModules from 'react-css-modules';// 修改className为styleNamerender( return &lt;div styleName="sample-camel" /&gt;)// 装饰组件export default CSSModules(ComponentSample, styles, &#123;allowMultiple:true&#125;);// webpack配置module.exports = &#123; module: &#123; loaders: [&#123; test: /\.css$/, loader: loaders: ['style?sourceMap', 'css?modules&amp;importLoaders=1&amp;localIdentName=[path]__[name]__[local]__[hash:base64:5]'], include: path.join(__dirname, 'css') &#125;, &#123; test: /\.(png|jpg|gif|svg)$/, loaders: ['url?limit=8192'], include: path.join(__dirname, 'image') &#125;] &#125;&#125;； 这样，不论是现有项目修改还是新项目从静态页面到react，都更为方便。 最后修改在生产环境的webpack配置。 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849module.exports = &#123; output: &#123; path: path.join(__dirname, 'asset'), filename: '[name].[chunkhash].js', publicPath: '/' &#125;, resolve: &#123; extensions: ['', '.js'] &#125;, devtool: false, plugins: [ new webpack.optimize.OccurenceOrderPlugin(), new webpack.DefinePlugin(&#123; 'process.env': &#123; 'NODE_ENV': JSON.stringify('production') &#125; &#125;), new webpack.optimize.DedupePlugin(), new webpack.optimize.UglifyJsPlugin(&#123; compress: &#123; warnings: false &#125; &#125;), new webpack.DefinePlugin(&#123; SITE_STATIC_PREFIX: JSON.stringify(SITE_STATIC_PREFIX), SITE_DYNAMIC_PREFIX:JSON.stringify(SITE_DYNAMIC_PREFIX) &#125;), new ExtractTextPlugin('[name].[chunkhash].css', &#123;allChunks:true&#125;), new HtmlWebpackPlugin(&#123; template:'scripts/index.ejs', minify:&#123; removeComments: true, collapseWhitespace: true, removeRedundantAttributes: true, useShortDoctype: true, removeEmptyAttributes: true, removeStyleLinkTypeAttributes: true, keepClosingSlash: true, minifyJS: true, minifyCSS: true, minifyURL: true &#125;, inject:true &#125;) ], module: &#123; loaders: [&#123;test: /.jsx?$/,loaders: ['babel'],include: path.join(__dirname, 'scripts')&#125;, &#123;test: /.js?$/,loaders: ['babel'],include: path.join(__dirname, 'scripts')&#125;, &#123;test: /.css$/,loader: ExtractTextPlugin.extract('style', 'css?modules&amp;importLoaders=1&amp;localIdentName=[path]__[name]__[local]__[hash:base64:5]'),include: path.join(__dirname, 'css')&#125;, &#123;test: /.(png|jpg|gif|svg)$/,loaders: ['url?limit=8192', 'image-webpack?bypassOnDebug&amp;optimizationLevel=7&amp;interlaced=false'],include: path.join(__dirname, 'image')&#125;] &#125;&#125;; 其中尝试加入图片压缩，但在windows环境下imagemin依赖的库会出现问题，目前没有解决方案，只能考虑在其他步骤中进行处理。 代码规范按照以下进行了代码重写。 重申命名规范，组件/页面单独文件夹，文件夹下index.js作为默认导出，使用到的多个组件在文件夹内创建[ComponentName.js]来引用。 按照要求将react-router的hashHistory替换为browserHistory，在上面的修改完成后，由于使用browserHistory导致的资源路径问题也同步解决了。]]></content>
      <tags>
        <tag>webpack</tag>
        <tag>react</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[使用esformat和其plugin来格式化es6及react代码]]></title>
    <url>%2F2016%2F07%2F02%2F%E4%BD%BF%E7%94%A8esformat%E5%92%8C%E5%85%B6plugin%E6%9D%A5%E6%A0%BC%E5%BC%8F%E5%8C%96es6%E5%8F%8Areact%E4%BB%A3%E7%A0%81%2F</url>
    <content type="text"><![CDATA[使用sublime esfomatter插件。 如eslint一样，配置.esformatter，添加esformatter和esformatter插件为项目依赖。]]></content>
      <tags>
        <tag>react</tag>
        <tag>es6</tag>
        <tag>format</tag>
        <tag>esformat</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[内网配置SublimeLinter和SublimeLinter-contrib-eslint来检查es6 react代码]]></title>
    <url>%2F2016%2F06%2F30%2F%E5%86%85%E7%BD%91%E9%85%8D%E7%BD%AEsublimelinter%E5%92%8Csublimelinter-contrib-eslint%E6%9D%A5%E6%A3%80%E6%9F%A5es6-react%E4%BB%A3%E7%A0%81%2F</url>
    <content type="text"><![CDATA[最近一直在做前端技术积累相关方面的事情，其中一项就是要起草一个前端规范。我觉得一切只要求人自觉做到而不提供规范化工具的规范都是耍流氓。参考现在项目使用的为react和es6，以及sublime，我找到了几个有用的东西： eslint eslint-plugin-react eslint-plugin-import SublimeLinter SublimeLinter-eslint 他们的关系是： eslint检查代码是否符合规范，使用eslint-plugin-react和eslint-plugin-import来检查es6 react语法。eslint已经支持es6，不需要使用babel-eslint。 SublimeLinter是连接SublimeLinter-xlint的框架型sublime插件，将检查结果等在sublime中显示。 SublimeLinter-eslint使用eslint的基于SublimeLinter的插件。SublimeLinter检测到配置的需要检查的文件，调用配置的lint，如SublimeLinter-eslint来检查。而SublimeLinter-eslint则使用eslint加载配置的规则来检查代码。 安装步骤前置条件：配置了npm代理可以使用npm安装。 在项目下运行 1npm install eslint eslint-plugin-react eslint-plugin-import --save-dev 解压下载的SublimeLinter和SublimeLinter-eslint到sublime的12（这一步只需要项目创建者执行一次）在项目下配置.eslintrc，或者直接运行 ./node_modules/.bin/eslint –init123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475可以得到一个基础的校验规则配置。可以参考这个[starter kit](https://github.com/coryhouse/react-slingshot/blob/master/.eslintrc)的配置``` json&#123; "extends": [ "eslint:recommended", "plugin:import/errors", "plugin:import/warnings" ], "plugins": [ "react" ], "parserOptions": &#123; "ecmaVersion": 6, "sourceType": "module", "ecmaFeatures": &#123; "jsx": true, "experimentalObjectRestSpread": true &#125; &#125;, "env": &#123; "es6": true, "browser": true, "node": true, "jquery": true, "mocha": true &#125;, "rules": &#123; "quotes": 0, "no-console": 1, "no-debugger": 1, "no-var": 1, "semi": [1, "always"], "no-trailing-spaces": 0, "eol-last": 0, "no-underscore-dangle": 0, "no-alert": 0, "no-lone-blocks": 0, "jsx-quotes": 1, "react/display-name": [ 1, &#123;"ignoreTranspilerName": false &#125;], "react/forbid-prop-types": [1, &#123;"forbid": ["any"]&#125;], "react/jsx-boolean-value": 0, "react/jsx-closing-bracket-location": 0, "react/jsx-curly-spacing": 1, "react/jsx-indent-props": 0, "react/jsx-key": 1, "react/jsx-max-props-per-line": 0, "react/jsx-no-bind": 0, "react/jsx-no-duplicate-props": 1, "react/jsx-no-literals": 0, "react/jsx-no-undef": 1, "react/jsx-pascal-case": 1, "react/jsx-sort-prop-types": 0, "react/jsx-sort-props": 0, "react/jsx-uses-react": 1, "react/jsx-uses-vars": 1, "react/no-danger": 1, "react/no-did-mount-set-state": 1, "react/no-did-update-set-state": 1, "react/no-direct-mutation-state": 1, "react/no-multi-comp": 1, "react/no-set-state": 1, "react/no-unknown-property": 1, "react/prefer-es6-class": 1, "react/prop-types": 1, "react/react-in-jsx-scope": 1, "react/require-extension": 1, "react/self-closing-comp": 1, "react/sort-comp": 1, "react/wrap-multilines": 1 &#125;, "globals": &#123; &#125;&#125; 也可以参考airbnb配置或者自行配置。 打开sublime顶部Tools -&gt; SublimeLinter -&gt; Lint mode，选择自己喜欢的检查时机。 Background: 准实时提示。 Load/save：打开/保存文件时。 Save only：保存时。 Manual：手动。请去Preferences -&gt; Package Settings -&gt; SublimeLinter -&gt; Key Bindings - Default查看快捷键设置，建议在Key Bindings - User里设置自定义快捷键。 至此，可以发现自己ugly代码左侧行号附近出现了提示，且在行内会有方框标识，且在sublime底部会有提示原因。如果觉得不方便查看，可以设置Tools -&gt; SublimeLinter -&gt; Debug mode，使用ctrl + `调出控制台来查看信息。 TODO：暂时没有具体研究每一项配置。 参考文章： Get Started with ESLint v1.0 Airbnb JavaScript Style Guide Airbnb React/JSX Style Guide React/JSX 编码规范]]></content>
      <tags>
        <tag>react</tag>
        <tag>es6</tag>
        <tag>lint</tag>
        <tag>eslint</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[阶段性前端开发项目待解决问题总结]]></title>
    <url>%2F2016%2F06%2F22%2F%E9%98%B6%E6%AE%B5%E6%80%A7%E5%89%8D%E7%AB%AF%E5%BC%80%E5%8F%91%E9%A1%B9%E7%9B%AE%E5%BE%85%E8%A7%A3%E5%86%B3%E9%97%AE%E9%A2%98%E6%80%BB%E7%BB%93%2F</url>
    <content type="text"><![CDATA[最近项目即将上线，终于有时间回顾这个以基于第三方框架制作的APP的webview为基础环境的webpack-react项目了。 待解决的问题配置管理开始使用webpack时对其不了解，也没有进行过开发环境、各个测试环境和生产环境方面的配置，对这方面不太了解，一些在不同环境下应该进行不同配置的全局变量需要在各个环境手动修改。该部分应该通过webpack的DefinePlugin进行设置，如 lang: javascript123456new webpack.DefinePlugin(&#123; VERSION: JSON.stringify("5fa3b9"), BROWSER_SUPPORTS_HTML5: true, TWO: "1+1", "typeof window": JSON.stringify("object")&#125;) 同时对于入口文件html引用的路径，使用模板的方式，如html-webpack-plugin来处理，以在不同环境下进行不同的配置。 三方库管理在目前的实现中，为了实现安卓的物理键功能，在入口页面html文件中引用了几个第三方js库。这些第三方库在js中也重复引入了，仅仅因为JS压缩等原因无法复用。 可以通过webpack的CommonsChunkPlugin将公共JS提取为公共文件以复用。同时配合html-webpack-plugin来解决物理键功能的问题。 组件化目前的站点在实现上，依然采用之前的目录结构，没有采用组件化的目录结构来开发。具体表现在将原来的html页面简单映射为react的一个js文件（一个component），其对应一个react-router的route。具体在页面内部，无法复用组件。如标签页、导航等。 这部分必须参考现有的优秀的react组件，区分出单个组件和框架的区别。哪些可以作为组件单独封装，哪些部分或功能封装成组件可能会影响页面其他部分，必须仔细斟酌，形成一个标准。 目前比较优秀的组件主要有react-modal、react-swipe等。至于一些很容易在百度上搜到的国内的知名组件库，如amaze ui react，或是ant design的react component，其组件质量良莠不齐，部分组件容易出现上述的影响页面其他部分的问题。不过最近看似乎amaze ui项目来了个新的技术主管的样子，新出的react组件质量好像高了不少。 在这个项目里，标准化是一个比较复杂的问题，只因为这是一个奇怪的hybird模式。 性能优化找到了一个非常好的总结和TODOs的文章]]></content>
      <categories>
        <category>web</category>
      </categories>
      <tags>
        <tag>webpack</tag>
        <tag>hybird</tag>
        <tag>react</tag>
        <tag>前端优化</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[React开发入门指南]]></title>
    <url>%2F2016%2F06%2F06%2Freact%E5%BC%80%E5%8F%91%E5%85%A5%E9%97%A8%E6%8C%87%E5%8D%97%2F</url>
    <content type="text"><![CDATA[用Jekyll和Markdown写的，使用的pygment的代码高亮没有调整，react相关代码会出现红框，无视就好，懒癌发作暂时不想研究。 代码是示例，仅作为参考。 不知不觉写了很多东西，有点杂，见谅。 React是什么React是基于JavaScript的，状态驱动的，操作虚拟DOM的UI框架。使用该框架有很多好处，对我来说，核心是将对DOM的操作隔离开，让开发人员专注于业务流程和状态。 与传统开发比较在传统的前端页面开发中，我们一般会给一个标签设置一个id或是类似的东西，以便对其进行操作，如：lang: javascript123456789&lt;div id='id_xxx'&gt;这是一个标签&lt;/div&gt;// 纯JSdocument.getElementByID('id_xxx')// JQuery$('#id_xxx')// 再去操作 而在React中，一般这么做：lang: javascript123456789101112131415161718// import省略// 为了比较完整展现一下结构，比上面偷懒写的代码多了很多class ComponentA extends React.Component&#123; constructor(props) &#123; super(props) this.state = &#123; stateTag: true &#125; &#125; render()&#123; // 进行一些预处理操作 let title = this.state.stateTag? '这是一个标签':'这不是一个标签' let arrayInfo = new Array(5).fill(false) let elems = [] arrayInfo.forEach((v,i) =&gt; (elems.push(&lt;div&gt; &#123;i + '-' + v&#125; &lt;/div&gt;))) return(&lt;div&gt;&#123;title&#125;&lt;div&gt;&#123;elems&#125;&lt;/div&gt;&lt;/div&gt;) &#125;&#125; 这样我们只需要关注什么样的场景下需要进行title值的修改，不需要关注ID之类的维护亦或一些复杂繁琐的DOM操作。想象一下如果是一个复杂的多级下拉选择框，选完了之后对应的列表需要进行自动更新。 React结构入门以上面的代码为例。Java从接触的时候的1.5发展到了1.8，多了很多并行运算、模板、闭包、线程安全等新特性，Python也不是一成不变，JavaScript也发展到了es6，es7正在路上。上面的代码，是基于es6。 lang: javascript12// 和大部分语音一致，引用依赖包/库，如Java、Python的import，C系列的include等import React from 'react' 12345678910111213141516171819202122232425262728293031// 定义一个React组件// 如果做过其他胖客户端的开发的话，类似Android、VB、C#等，extend Viewclass ComponentA extends React.Component&#123; // 非常熟悉的面向对象的概念中的构造函数 // props即使用ComponentA时传入的初始化参数 constructor(props) &#123; super(props) // 设置该组件构造时的状态 this.state = &#123; stateTag: true &#125; &#125; // 初始化完成开始渲染DOM，React在这里计算需要修改哪些DOM节点并进行更新 render()&#123; // es6的关键字，不再使用var，var的作用域不好控制 // let声明变量，const声明常量 let title = this.state.stateTag? '这是一个标签':'这不是一个标签' let arrayInfo = new Array(5).fill(false) let elems = [] // forEach为es6中的数组遍历 // (param)=&gt;(expression(param))为新的操作符，param为形参，表示对param立刻执行expression(param) // (v,i)是forEach的可变形参列表，可以为1-3个参数，分别是数组项值、下表、数组引用 // 都是语法糖，整个含义就是遍历数组，对于每个数组项执行一个操作 arrayInfo.forEach((v,i) =&gt; (elems.push(&lt;div&gt; &#123;i + '-' + v&#125; &lt;/div&gt;))) // return中写静态页面，HTML。需要注意的主要有三点： // html关键字class修改为className // style通过对象传入，带有“-”的修改为驼峰命名，如style="padding-top:1rem"修改为style=&#123;&#123;paddingTop:'1rem'&#125;&#125; // 列表需要加入唯一key，如key = &#123;列表名 + 页号 + 下标&#125; return(&lt;div&gt;&#123;title&#125;&lt;div&gt;&#123;elems&#125;&lt;/div&gt;&lt;/div&gt;) &#125;&#125; 12// 使用方式如下，传入一个对象到init属性，在ComponentA中通过this.props.init访问&lt;ComponentA init=&#123;&#123;foo:bar&#125;&#125; /&gt; 常用声明周期函数lang: javascript123456789101112// render之前调用componentWillMount() &#123; // 修改state&#125;// render之后调用componentDidMount() &#123; // 发送异步请求&#125;// 销毁之前调用componentWillUnmount() &#123; // 清理定时器、中断请求等&#125; 更多详情参考阮一峰的React介绍（es5版代码）或者官网（还是es5） 注：阮一峰的博客是15年3月写的，部分内容react可能更新后取消了。比如不再使用JSX，拥抱es6。 像React一样思考React中，props和state是很容易混淆的。什么时候使用props？什么时候使用state？哪些需要在组件内部的state进行管理？都是设计到组件设计的问题。 React最佳实践中，将UI组件分为两种：纯展示类组件和业务类组件。其中，纯展示类组件只负责展示，没有自己的state，如：使用宽a高b位置多少的页面空间展示一种来源为xxx的图片。而父组件负责处理组件状态，如由图片、剪头、分页等组成的轮播图组件，负责处理显示哪张图片，点击的回调是什么，什么时候切换图片，是否可以滑动等。 那么，一个基于react的web app可能就是这样： lang: html12345678910// 入口index.&lt;!DOCTYPE html&gt;&lt;html&gt;&lt;head&gt; &lt;title&gt;入口&lt;/title&gt;&lt;/head&gt;&lt;body&gt; &lt;script type="text/javascript" src="...app.js"&gt;&lt;/script&gt;&lt;/body&gt;&lt;/html&gt; lang: javascript12345678910111213141516171819202122232425// app.jsclass ComponentA extends React.Component&#123; constructor(props) &#123; super(props) this.state = &#123; // 初始化 &#125; &#125; // 注入子组件进行调用更新父组件状态 updateState(param) &#123; this.setState(param) &#125; render () &#123; // 许多状态和cases，以判定页面应该显示成什么样，拼装对应的组件，之后填充到页面 let componentArrayA = [] if (this.state) &#123; componentArrayA.push(&lt;ComponentX callbackFunction=&#123;this.updateState.bind(this)&#125;&gt;&lt;/ComponentX&gt;) &#125; return ( &lt;div&gt;&#123;componentArrayA&#125;&lt;/div&gt; ) &#125;&#125; 很快，就会出现几个问题： 浏览器里我复制链接，我可以在新的浏览器里粘贴就可以打开对应页面，如果没有登录跳到登录页，使用react如何做到？ 使用react，页面一多，状态的维护难度会不会爆炸？ 要解决这些问题，需要引入新的框架。 相关知识技术React-router第一个问题，其实是路由方面的问题。 在以前接触的Java前端网页开发中，我们是通过Spring-MVC来进行一些基础路由设置，然后将路由处理映射到Controller，在Controller中处理请求并返回对应页面。其中，在请求到Controller之前，会通过一些filter进行处理，比如shiro来进行权限验证（登录与否等）。这样就需要引入react-router。 react-router是一个前端路由框架，监听浏览器的url请求，并进行相应的处理。lang: html12345678910111213141516171819&lt;Router history=&#123;hashHistory&#125;&gt; &lt;Route path="/" component=&#123;Home&#125; onEnter=&#123;function()&#123; document.getElementById('g-header-line').style.height = '0px';/*Home页面需要进行特殊处理*/ let TRUE = true pushPageTrace(TRUE, escape('http://web2native|channel=goto_xhtml*path=login/xhtml/unlogin_menu_location.xhtml')) &#125;&#125; onLeave=&#123;function()&#123; let height = 0; let parser = new UAParser(); let result = parser.getResult(); if (result.os.name === 'iOS') &#123; if (result.os.version.substr(0, result.os.version.indexOf('.')) &gt; 6) &#123; height = 20 * (document.documentElement.clientWidth / 320); &#125; &#125; document.getElementById('g-header-line').style.height = height + 'px'; &#125;&#125;/&gt;&lt;/Router&gt; hashHistory用的是react-router提供的基于浏览器自带history制作的history.js的一个历史记录数据结构，使用的是http://xxx/#/xxx?hash=xxx的形式。 标签中path即#/path，component即自己写的react组件，onEnter即进入页面前的处理，可以在此对路由进行预处理，onLeave同理。通过这种方式，能解决前端路由问题。 题外hashHistory的#总是有点奇怪的，表现上有点像把html的锚点重定义了。在现在H5的语义化大环境下，这并不是一个好的解决方案。所以，react-router提供了browserHistory这样传统的解决方案。 在之前的项目中没有使用browserHistory的原因有： 前期调研不充分。 时间紧张，没有时间进行对应改造。 闲暇时间尝试过修改为browserHistory，涉及到了一些代码目录结构修改和路由重定向的问题，还有一些部署优化的问题，暂时没有动手。 Redux还好我们的应用不是很大，使用react-router拆分后，页面状态没有爆炸，暂时用不到redux。 redux是一个状态树管理框架，主要解决的问题就是状态的管理，可以类似理解为一个状态管理中心。不理解可以参考接触的各种注册/提供/消费模式，如Dubbo，在redux中注册，标明谁来更新状态，状态更新后通知谁更新。 暂时只阅读了相关文档没有实际使用，不再赘述。 npm和webpack及其他用之前的项目理解，npm和webpack共同构成了一个maven。 npm包管理工具，依赖管理工具，下载包，执行配置命令等。 webpack发布工具，发布前预处理等。 package.json作用类似pom.xml 开发工具一般就是sublime text和atom，两种都是非常好的编辑器，并且开发es6+react时并没有太多差别，都有相关插件。 sublime text3离线安装插件需要安装PyV8，步骤参考这里。 打开Preferences &gt; Browse Packages。 向上一级，找到Installed Packages/目录，没有则手动创建。 下载Package Control.sublime-package，复制到Installed Packages/。 重启sublime text3。 atomatom可以直接问(度娘)[http://jingyan.baidu.com/article/375c8e19c3105a25f2a22901.html]，初始步骤只有一个： lang: javascript1npm install language-asciidoc 相关插件离线下载插件包安装地址：sublime相关，atom相关。请阅读英文介绍，使用es6相关的，使用人数较多的插件。 两种编辑器需要的插件基本相同，找关键字，： babel：es6语法插件。 emmet：HTML标签自动补全。 autocomplete：代码自动补全。 react snippets：react代码片段。 其他暂时没有想到，可以自行在网站检索。 因为GBK字符集问题，sublime额外需要ConvertToUTF8和Encoding Helper插件。atom没有使用过暂不清楚。 和掌银框架、APP使用和掌银结合时，主要有两个问题需要解决： 1x、2x和3x缩放和iOS沉浸式webview适配。 Android物理返回键处理。 缩放和沉浸式webview适配缩放和适配相对比较简单： lang: javascript1234567891011121314151617var docEl = document.documentElement, resizeEvt = 'orientationchange' in window ? 'orientationchange' : 'resize', recalc = function() &#123; var parser = new UAParser(); var result = parser.getResult(); var clientWidth = docEl.clientWidth; if (!clientWidth) return; baseSize = 20 * (clientWidth / 320) docEl.style.fontSize = baseSize + 'px' // iOS 7以上的都为沉浸式，需要额外的高度 if (result.os.name === 'iOS') &#123; if (result.os.version.substr(0, result.os.version.indexOf('.')) &gt; 6) &#123; document.getElementById('g-header-line').style.height = baseSize + 'px'; &#125; &#125; &#125;; Android物理返回键处理物理返回键比较复杂，原因主要为，需要切换webview。这里不得不说，有些页面，如登录、支付，还是能做成native弹框以便到处调用比较好，那样就不会有这个问题了。 使用webview cookie来实现返回 在该APP中，多个webview之间共享cookie。利用cookie，我们可以实现类似于native的返回。目前使用的技术有：react、react-router、react-cookie。 第一版思路： 各个页面专注自己的业务逻辑，将返回封装到NavBar。 压栈操作放在react-router的onEnter方法中来进行操作。 流程如图： 代码如下：lang: javascript1234567891011121314151617181920// 压栈函数function pushPageTrace() &#123; let trace = Cookie.load(Global.PAGE_TRACE) ? Cookie.load(Global.PAGE_TRACE) : new Array() let storeUrl = window.location.href trace.push(storeUrl) Cookie.save(Global.PAGE_TRACE, trace)&#125;// 压栈&lt;Route path='route' component=&#123;Com&#125; onEnter=&#123;function()&#123;pushPageTrace()&#125;&#125;/&gt;// 返回按钮export default class NavBar extends React.Component &#123; goBack() &#123; let pageTrace = Cookie.load(Global.PAGE_TRACE) let backUrl pageTrace.pop() backUrl = pageTrace.pop() Cookie.save(Global.PAGE_TRACE, pageTrace) window.location.href = backUrl &#125;&#125; 在实际使用的过程中，有几个问题： 需要有个时机来清空栈。 部分页面需要设置特殊的返回页面，如支付结果页面不再回到支付订单详情确认页面而是回到商品信息页面。 对栈底需要进行特殊处理，不能空栈。 修改如下：lang: javascript123456789101112131415161718192021222324252627282930// 压栈函数function pushPageTrace(clear = false, specialUrl = null) &#123; let trace = clear ? new Array() : Cookie.load(Global.PAGE_TRACE) ? Cookie.load(Global.PAGE_TRACE) : new Array() let storeUrl = specialUrl ? specialUrl : window.location.href trace.push(storeUrl) Cookie.save(Global.PAGE_TRACE, trace)&#125;// 返回按钮export default class NavBar extends React.Component &#123; goBack() &#123; if (!this.state.clicked) &#123; this.setState(&#123; clicked: true &#125;) let pageTrace = Cookie.load(Global.PAGE_TRACE) let backUrl if (pageTrace.length == 1) &#123; backUrl = pageTrace[0] &#125; else if (pageTrace.length == 2) &#123; pageTrace.pop() backUrl = pageTrace[0] &#125; else &#123; pageTrace.pop() backUrl = pageTrace.pop() &#125; Cookie.save(Global.PAGE_TRACE, pageTrace) window.location.href = backUrl &#125; &#125;&#125; TODO 如何使用browserHistory。 使用Redux。 制作自己的组件库，支持自定义样式。 css压缩优化。 scss和less。 淘宝在移动端和chrome等使用webp，在其他端使用jpeg和png，如何做到。 Controller层session和shiro/JWT与前端路由的使用。 使用webpack插件做到如maven的各个环境独立配置，文本替换，加入js等文件的hash值。]]></content>
  </entry>
  <entry>
    <title><![CDATA[Hybird模式下webview中的物理返回键问题的解决方法]]></title>
    <url>%2F2016%2F05%2F19%2Fhybird%E6%A8%A1%E5%BC%8F%E4%B8%8Bwebview%E4%B8%AD%E7%9A%84%E7%89%A9%E7%90%86%E8%BF%94%E5%9B%9E%E9%94%AE%E9%97%AE%E9%A2%98%E7%9A%84%E8%A7%A3%E5%86%B3%E6%96%B9%E6%B3%95%2F</url>
    <content type="text"><![CDATA[最近做的一个移动端H5项目，需要嵌入某个移动APP中。为了达到近似APP的效果，在H5页面顶部设计了标题栏和返回键。 使用history.goback的问题在网页浏览器中，一般使用浏览器的自带回退来返回上一页，网站一般开发只对回退时是否提交上一页表单等问题进行处理，并不修改浏览器的回退行为。而在Hybird模式下，部分功能，如登录、绑卡、支付等流程都是在native下进行，这样就会出现native和webview之间的跳转，会导致history.goback失效。所以需要自己实现一套返回机制。 使用webview cookie来实现返回在该APP中，多个webview之间共享cookie。利用cookie，我们可以实现类似于native的返回。目前使用的技术有：react、react-router、react-cookie。 歌王争霸栈v0.0.1第一版思路： 各个页面专注自己的业务逻辑，将返回封装到NavBar。 压栈操作放在react-router的onEnter方法中来进行操作。 流程如图： 代码如下：lang: javascript1234567891011121314151617181920// 压栈函数function pushPageTrace() &#123; let trace = Cookie.load(Global.PAGE_TRACE) ? Cookie.load(Global.PAGE_TRACE) : new Array() let storeUrl = window.location.href trace.push(storeUrl) Cookie.save(Global.PAGE_TRACE, trace)&#125;// 压栈&lt;Route path='route' component=&#123;Com&#125; onEnter=&#123;function()&#123;pushPageTrace()&#125;&#125;/&gt;// 返回按钮export default class NavBar extends React.Component &#123; goBack() &#123; let pageTrace = Cookie.load(Global.PAGE_TRACE) let backUrl pageTrace.pop() backUrl = pageTrace.pop() Cookie.save(Global.PAGE_TRACE, pageTrace) window.location.href = backUrl &#125;&#125; 守望仙栈v0.1.0在实际使用的过程中，有几个问题： 需要有个时机来清空栈。 部分页面需要设置特殊的返回页面，如支付结果页面不再回到支付订单详情确认页面而是回到商品信息页面。 对栈底需要进行特殊处理，不能空栈。 修改如下：lang: javascript123456789101112131415161718192021222324252627282930// 压栈函数function pushPageTrace(clear = false, specialUrl = null) &#123; let trace = clear ? new Array() : Cookie.load(Global.PAGE_TRACE) ? Cookie.load(Global.PAGE_TRACE) : new Array() let storeUrl = specialUrl ? specialUrl : window.location.href trace.push(storeUrl) Cookie.save(Global.PAGE_TRACE, trace)&#125;// 返回按钮export default class NavBar extends React.Component &#123; goBack() &#123; if (!this.state.clicked) &#123; this.setState(&#123; clicked: true &#125;) let pageTrace = Cookie.load(Global.PAGE_TRACE) let backUrl if (pageTrace.length == 1) &#123; backUrl = pageTrace[0] &#125; else if (pageTrace.length == 2) &#123; pageTrace.pop() backUrl = pageTrace[0] &#125; else &#123; pageTrace.pop() backUrl = pageTrace.pop() &#125; Cookie.save(Global.PAGE_TRACE, pageTrace) window.location.href = backUrl &#125; &#125;&#125;]]></content>
  </entry>
  <entry>
    <title><![CDATA[第一次ReactJS前端开发记录]]></title>
    <url>%2F2016%2F05%2F08%2F%E7%AC%AC%E4%B8%80%E6%AC%A1reactjs%E5%89%8D%E7%AB%AF%E5%BC%80%E5%8F%91%E8%AE%B0%E5%BD%95%2F</url>
    <content type="text"><![CDATA[这是一个坑 从UI和静态页面到组件ReactJS结构和普遍的前端web技术非常不一样。从流程上来说，一个页面的更新，是跟业务相关的：从后台取到初始化数据，进行业务流程的判断，然后将数据加工处理到页面上。而当前很多专门做前端的公司，并不注重技术更新，用的还是JQuery速成培训那一套；同时第一次采用ReactJS并没有设计前端静态页面要求的经验，导致合作起来问题比较多。同时，很多问题在测试时才暴露出来。而且，很多也不够语义化。 TIPS H5 CSS设置 语义化 组件化 性能优化]]></content>
  </entry>
  <entry>
    <title><![CDATA[近期某项目前端开发梳理——无知、未知、摸着石头过河]]></title>
    <url>%2F2016%2F04%2F23%2F%E8%BF%91%E6%9C%9F%E6%9F%90%E9%A1%B9%E7%9B%AE%E5%89%8D%E7%AB%AF%E5%BC%80%E5%8F%91%E6%A2%B3%E7%90%86%E6%97%A0%E7%9F%A5%E6%9C%AA%E7%9F%A5%E6%91%B8%E7%9D%80%E7%9F%B3%E5%A4%B4%E8%BF%87%E6%B2%B3%2F</url>
    <content type="text"><![CDATA[项目背景目前大部分传统行业互联网项目都是由于大型互联网公司携用户量，上了新的威胁传统行业的项目，不得不上，本银行项目也不外如是，简称为项目Y吧。项目Y是迫于互联网压力产生的一系列项目群中的一个子项目，说起来很简单，想要实现的功能就是通过加强银行和商户目标用户群的联系来加强银行和商户间的合作关系（项目还没上线，姑且用一种比较晦涩的说法）。 项目启动项目启动时一般需要确定的有大体需求、概要设计、需要对接的外系统。分别对应的就是业务、开发、部门合作。 流程和接口 业务和开发：以需求文档为基础，以UE原型为具体交流工具。 对接外系统：行内系统M、行内系统P、行内系统C。 技术架构前端：ReactJS、动静分离、Spring-MVC以及某不知名移动端APP框架。后台业务层：Dubbo、Zookeeper等。 设计开发业务需求由业务部门提出需求，在UE组的帮助下设计原型，然后和开发进行沟通，讨论是否能实现相关业务需求，设置需求的优先级。讨论过程中设计的外部因素也需要和外部业务和技术部门进行沟通。 技术架构后端service分层架构，包括数据层（一堆访问本系统数据库的dao和收发外系统报文的接口程序）、基础服务层（包装dao和一些基础接口的服务层）、业务服务层（和业务逻辑相关的服务，主要为本系统的服务）。业务服务层通过Dubbo对外暴露。 前端动态资源使用Spring-MVC来进行动态资源管理，主要处理ajax请求。暂时不适用shiro、session等技术。使用redis来访问所需的外系统数据。 前端静态资源使用ReactJS和相关技术来开发前端UI，暂时没有使用redux等技术方案。ReactJS网页嵌入外部系统的APP客户端中。 坑UE原型由业务绘制 业务人员的主要工作并不是绘制UE原型，学习Axure需要一段时间。 业务人员的日常工作是处理大体的、非具象、需要多方沟通的事务，或是有既定规章可循的常规事务，而不是设计和确认新事物流程细节，更不是设计用户体验。 时间紧迫的情况下，不论什么理由，还是由专业的人做专门的事情，效率比较高。 未知的技术难度 工期紧迫，却因为技术研究小组的推荐放弃了熟悉的基于JQuery前端技术方案，采用更新更适合移动端但学习成本较高的ReactJS。而且由于一些如需要支持优先级更高的事项或是人事变动等原因，技术研究小组的支持力度并不足以支撑开发小组使用新技术。 开发小组组员技术实力参差不齐。大部分研究、示例、实践都表明，增加人员并不一定会提升开发效率，尤其是新增人员本身能力跟不上开发进度时，沟通、指导、修正等成本大大增加。同时，技术实力较强的人员由于这些事务的打断，切换工作状态花费了更多的时间。 较多的正在升级更新的外接系统。如果外接系统稳定，且剧本稳定的可控的测试条件，这部分只是一个比较耗时的工作，难度不是特别大；但在外系统整体需要升级，测试环境不稳定的情况下进行系统对接，对接复杂度直接就变成了f(n) = t^n。而且每个系统都有自己的升级更新打包时间，测试账号可能对多个对接系统提供，系统升级时测试环境可能不同步等，每个系统的协调时间可能需要十分钟到半个小时不等，极大降低开发效率。一个购买选卡支付的流程两周没有走通。 额外的设计和开发。如为了验证开发结果，需要绕过外接系统进行验证，同时还有对相关数据的维护，以及区分目标生产系统代码和解决环境问题（如业务测试环境、压力测试环境）等产生的额外代码。 传统适配问题。在使用ReactJS且嵌入使用了由于众所周知的原因采用的应用范围极窄的未知框架开发的APP的情况的，适配问题的解决成为了需要众多环节合作的一个流程很长的问题。 ReactJS和其他传统技术合作的问题。比如，难以向UI和静态页面制作方描述清楚需求说明和规格要求；对于一般人员学习成本较高。 传统的设计模式和新的动静分离模式带来的变化，以及前端组件化带来的一系列前端程序设计和优化问题，如代码包结构、压缩、各个环境的资源替换等。]]></content>
  </entry>
  <entry>
    <title><![CDATA[使用ReactJS简单封装BaiduMap]]></title>
    <url>%2F2016%2F04%2F09%2F%E4%BD%BF%E7%94%A8reactjs%E7%AE%80%E5%8D%95%E5%B0%81%E8%A3%85baidumap%2F</url>
    <content type="text"><![CDATA[最近需要使用百度地图来获取地理位置定位，用ReactJS封装了一下。 要点： 希望百度地图加载不影响ReactJS生命周期 将百度地图回调方法和ReactJS融合 目前百度地图没有离线API，官网上方式为 lang: html1&lt;script type="text/javascript" src="http://api.map.baidu.com/api?v=2.0&amp;ak=您的密钥&amp;callback=回调方法"&gt;&lt;/script&gt; 在页面嵌入了百度地图后，会异步获取一些js脚本，实现地图功能的加载，且加载成功与否难以控制。因此，需要在React组件加载完成的时候加载百度地图。 lang: javascript1234567891011componentDidMount() &#123; window.initBaiduMap = null let script = document.createElement('script') script.type = 'text/javascript' script.src = this.state.url + '&amp;ak=' + this.state.ak + '&amp;callback=initBaiduMap' window.initBaiduMap = this.locate.bind(this) document.body.appendChild(script)&#125;componentWillUnmount() &#123; window.initBaiduMap = null&#125; 产生的问题是： 使用了window对象，将React组件的方法绑定到了全局。 在网络异常时没有进行处理。 对于第2点问题，曾经使用了js中的try catch和绑定onerror来处理，没有成功，待解决。]]></content>
  </entry>
  <entry>
    <title><![CDATA[使用ReactJS实现一个老虎机抽奖组件]]></title>
    <url>%2F2016%2F02%2F27%2F%E4%BD%BF%E7%94%A8reactjs%E5%AE%9E%E7%8E%B0%E4%B8%80%E4%B8%AA%E8%80%81%E8%99%8E%E6%9C%BA%E6%8A%BD%E5%A5%96%E7%BB%84%E4%BB%B6%2F</url>
    <content type="text"><![CDATA[背景最近的项目技术专家组建议使用ReactJS进行移动Web前端页面开发，理由是要Web前端组件化。便进行了一些研究。 ReactJS基础基本的介绍参考官网即可。或者参考阮一峰的博文。英文好的可以参考reactjs-tutorial-a-comprehensive-guide。另外，极客学院的教程也不错——如果不嫌时间长的话。 实现老虎机设计思路整个老虎机抽奖流程比较简单： 进入老虎机界面，根据客户信息判断抽奖资格。 开始抽奖，发送后台请求。 获得并显示抽奖结果。对于前端老虎机组件，需要做的事有： 根据初始化数据初始化老虎机，包括奖品信息图文和主流程之外的如规则说明、即时中奖信息等。 点击开始，生成动画使老虎机的筹码图案不停滚动。 获取到服务器返回结果后，使老虎机图案停止滚动，显示恰当的图案。 主要难点 没有接触过前端动画。 ReactJS属于新接触的技术。 相关参考基于JQuery的老虎机基于ReactJS的图片切换DEMO 实现代码只实现了基本流程，具体使用根据实际UI和业务需要再进行修改。戳这里，欢迎指正]]></content>
  </entry>
  <entry>
    <title><![CDATA[组件化web开发和UI设计落地的思考]]></title>
    <url>%2F2015%2F12%2F20%2F%E7%BB%84%E4%BB%B6%E5%8C%96web%E5%BC%80%E5%8F%91%E5%92%8Cui%E8%AE%BE%E8%AE%A1%E8%90%BD%E5%9C%B0%E7%9A%84%E6%80%9D%E8%80%83%2F</url>
    <content type="text"><![CDATA[此文废弃，ReactJS和inline style，css module就是我想要的背景最近项目UED小组开了一次会，目的是想了解各个开发小组对前端的需求和目前现有项目的设计规范、技术要点。平台技术大牛在会议中透露了想要进行组件化web开发的想法，然后我就有了点想法。设计和开发之间，总是有那么点沟通或是理解上的差异，加上各自的知识面和约束都不尽相同，这就导致设计出来的UE、UI与开发成果有一定的出入。组件化能不能帮助解决这个问题？边写这篇小文边试验一下也是个不错的方法。 需求首先要明确自己想要的组件是什么样的。 目前，我们大概有这么几种需要进行web开发的地方 PC web Mobile phone web（触屏） App webview Pad web UI设计在大部分情况下，设计出来的UI或多或少会有一定的规则： 按照一般思路，UE倾向于将常用的组件行为统一，最典型的就是确认弹出框的确定居右，颜色绿色，取消按钮灰色等设置。 按钮不同状态的形状、颜色等，状态转换时的形状、声音、动画等，如悬浮时颜色的变化，悬浮时菜单的动画。 打开新页面和返回的动画方向相反，激活的标签图标字体更大更显眼等。 组件设计类似这样的设计，一方面可以指导用户体验一致性的实现，不至于出现同是弹出警告一个标题背景红色一个绿色的情况；另一方面也可以便于前端工程师将同类组件封装，供其他人调用。 组件有自己的样式，不和其他未知的样式冲突。 组件有自己的相关逻辑代码，不和其他未知的逻辑代码冲突。 不需要占位符，使用者可以自己将组件赋值给变量，用自定的id或者别的选择器来告知组件库识别，并进行初始化。 相关技术Web非Web经历曾经有几个移动项目，我参与了其中UE设计、UI审核、监督UE和UI落地的工作。更久以前，我还进行过一个大型项目的前端web开发。 远古记忆中参与的PC web前端开发称这个项目为项目pancake好了，简化为项目p，不要问我为什么。项目p的前端为PC web，研发遵循用Axure制作低保真原型并和相关方确认需求的方式，经过多次重构，确定一个版本再进行增量设计的方式。在UI方面，由专门的小组按照UE设计UI，并实现了静态web页面，包括css的编写和基本的页面HTML，确保静态页面和UI设计一致。开发人员则根据静态页面来开发，编写业务逻辑。现在看来，在实施过程中，有这么几个方面的问题。 远古UE刚开始用Axure，都是赶鸭子上架，啥都不会瞎搞，连个公共库都没有。这时还分了好几个项目组，每个小组设计各自的UE，结果就是一个按钮，有方的，有圆的，有圆角矩形的，有拟物风格的，有扁平风格的，整个就是个大杂烩。不久在一个碰头会上，我们立刻发现了这个问题，UE组遍立刻把实现一个基础的带有导航条、模态框、按钮、分割线等的共享库提高到了最高优先级。 从UI到开发当时我只涉及了UE设计和前端开发，UI设计和静态页面都是别的团队做的，对UE到UI和UI到静态页面不甚了解。大体情况就是有一个到两个UI设计人员，然后有几个前端工程师将UI设计转化为静态页面。 这个时候，开发的方式还比较古老，代码里都是这样的： lang: html123456789&lt;link rel="stylesheet" type="text/css" href="a.css"&gt;...&lt;link rel="stylesheet" type="text/css" href="n.css"&gt;...&lt;div id="xxx" class="class-a class-b ... class n"&gt;&lt;/div&gt;...&lt;script type="text/javascript" src="a.js"&gt;&lt;/script&gt;...&lt;script type="text/javascript" src="n.js"&gt;&lt;/script&gt; 在开发过程中，碰到了这么几个问题： 静态页面按照UE页面分配给不同的人去实现，只有页眉和页脚采用了公共样式，其他部分只有口头约定，并没有设计公共样式，存在大量拷贝复制的css样式。 css命名不规范，存在大量以人名命名的css样式，后期维护困难。 前端公共库函数开发时遇到css样式冲突和前端业务开发遇到命名冲突的问题。 一个控件的css调整涉及多个页面。 基于古怪的移动端跨平台框架的app项目在这几个项目中，UI的实现流程基本上是这样： 技术比较好的开发人员实现一个典型页面。 其他人拿着UI的标注，对照UE和典型页面，实现自己的页面。 这种模式下，大部分都是copy-paste，而且很多开发人员并没有写过css，也很少做过直接从UI设计稿实现一个页面的工作，对UE、UI的设计目的的理解不是很到位。同时UI也缺乏一个可参考的规范，标注出某个类型的按钮用在什么场景，有什么样的样式，对应哪种状态。这就导致页面开发出来和设计稿相去太远。很多开发者都需要经过一个项目，才知道如何解读UI设计。当时就想，如果能提供一个组件，开发者只需要引用，可以自己进行赋值，不会造成命名冲突，不需要关注样式，这样能更方便开发出如设计一样的界面吧。 吐个槽：这个宣称跨平台一次便携到处编译的框架，基本原理就是写了两个解析器来解析xhtml页面文件，一个对应iOS，一个对应Android，解析成java和objc。效率什么的暂且还是可以的，优化什么的是个谜，代码风格非常hybird，动效想想就好。在这两个项目里，UE和UI的设计由于框架的原因，受到了极大限制，稍微复杂一点的多选项关联修改都很难实现，对关联数据的校验也陷入了泥潭。更可怕的是，到处是不规范的全局变量名，css、lua函数都是每个人各写各的，充满了copy-paste风格的写法，加上类似php+js+html的混杂写法和缺乏有效的语法高亮支持，整个就是个噩梦。]]></content>
      <categories>
        <category>前端</category>
      </categories>
      <tags>
        <tag>前端</tag>
        <tag>组件化</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Java系Dubbo、Zookeeper系统服务拆分记录]]></title>
    <url>%2F2015%2F12%2F11%2Fjava%E7%B3%BBdubbozookeeper%E7%B3%BB%E7%BB%9F%E6%9C%8D%E5%8A%A1%E6%8B%86%E5%88%86%E8%AE%B0%E5%BD%95%2F</url>
    <content type="text"><![CDATA[事情发展情况总是偏离人的预想，尤其是业务发展和系统架构设计。一段时间后，一个新业务功能的上线往往伴随着几个相关功能的开发小组加班。同时甲组功能A可能依赖乙组功能B，乙组由于某个需求要更改功能B，而甲组开发新功能需要继续依赖功能B，且分配的开发时间并不一致。这样，协调起来会非常麻烦，效率也十分低下。于是，服务拆分的呼声越来越烈。经过几个月的研究、拆分、测试、上线，终于初步解决了服务间相互依赖的问题，便记录一下。 理想并不丰满任何业务系统的架构都是和业务紧密关联的，当时拟定有几个业务产品，一个后台管理，自己建立用户体系和账户体系，对接外系统接口，底层提供一系列日志、事务等平台服务。这个时候，分层逻辑是这样的： 页面展现层：web、Controller。 业务逻辑层：services。 平台服务层：Utils。 基础设施层：Database、Logs。 项目结构是这样的： Utils：提供统一异常管理、日志服务、事务处理、服务注册和发布、日期转换等工具类。 Apis：映射数据库表的domain类＋各个业务逻辑的Interfaces。 Services：各个产品服务实现类。 Web：MVC层，访问服务并展示页面。 并且规定了Service相关的编码规范，如： 不同产品Service之间需要通过Interface调用，不能直接调用实现。 所有产品业务类Service不能直接调用Dao，需要在上面封装一层基础Service。 Service调用不能形成循环依赖。 业务逻辑必须放在Service中，不能放在Controller里。 分层结构中不允许逆向调用，即下层不允许调用上层的代码。 看起来不错，然而domain呢？产品直接调用这些参数类型怎么办？各个产品Service相互调用，产品内部是否需要封装别的产品的Interface？后来才知道，这些都是坑。 现实很骨感当时工期很紧，团队新组建，还要和别的团队一起开发，技术人员素质参差不齐，到后来规定执行不力，但勉勉强强没出大问题。 后来，只有三个产品上线，其中两个是用户体系和账户体系，也就是说真正业务部分只有产品A，其它产品都没有什么活力。这时候倒也没有什么问题。可产品是会增加的。产品增加，就会出现如下情况： 而且，出于项目迭代、运维管理的需要，会有上线窗口，这就导致了Service B 2.0部分代码提交，但还没有上线，Service A却需要上线的情况。更有可能有多个Service依赖不同版本的同一个Service的情况出现。这时候面临的就是一个功能的修改，都可能有好几个小组加班。 经过几个新产品的开发和外部接口变换导致的内部代码的调整，可以预见，随着产品的增加，整个系统内部的耦合性会急剧增加，新功能、新产品的开发会越来越困难，一个功能点可能会涉及多个产品的更改，并且存在由于种种原因不使用Interface直接使用Service的情况，典型如图所示： ABCD可能属于不同的产品，ACD可能需要不同版本的B的method1的实现，Class B也有可能需要修改，且各自的deadline并不相同。这就存在了B从version 1到version 2的修改过程中，其它产品夹带代码的问题。为了解决这个问题，服务拆分小组对现有代码进行了分析，发现现有代码存在几个问题： Domain使用了Spring的ApplicationContext.getContext方式来获取Service实例。 Service没有使用Interface，直接使用了实现类。 产品A直接使用了产品B的domain来传递数据。 为了解决这些问题，服务拆分小组重新设计了服务开发的规范： Domain不允许使用Service，保持Domain的纯洁。 对外提供服务的返回值采用基本数据类型或者定义VO类。 对外提供的服务必须在实际调用的服务上再封装一层。 调用其他产品的服务必须时必须封装一层，并实现自己的VO，避免对象污染。 如图： 这样解决了上面的问题，唯一的问题是结构更加复杂了。 遗留问题分布式事务，老大难问题了。]]></content>
      <categories>
        <category>架构</category>
      </categories>
      <tags>
        <tag>架构</tag>
        <tag>IoC</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Maven使用记录（一）——maven的安装和基础配置]]></title>
    <url>%2F2015%2F12%2F06%2FMaven%E4%BD%BF%E7%94%A8%E8%AE%B0%E5%BD%95%EF%BC%88%E4%B8%80%EF%BC%89%E2%80%94%E2%80%94maven%E7%9A%84%E5%AE%89%E8%A3%85%E5%92%8C%E5%9F%BA%E7%A1%80%E9%85%8D%E7%BD%AE%2F</url>
    <content type="text"><![CDATA[Maven是一款非常好用的项目管理软件，主要用于项目构建，依赖管理等，简介出门右转参见百度百科，亦或去官方网站。 使用和配置这里主要介绍windows下maven的使用和配置。 要使用maven，首先确保安装了JDK，然后再去官方网站下载maven。根据情况——一般是操作系统和解压工具——选择zip或者tar.gz下载，然后解压到自己选择的目录或是文件夹下，即为maven的根目录。比如，我解压出来的目录结构是D:\LittleThings\apache-maven-3.2.5，包含bin、conf、lib、README.txt等目录和文件。所以，D:\LittleThings\apache-maven-3.2.5即我的maven根目录。​配置环境变量，以Windows为例。新增环境变量M2_HOME，我这里值为D:\LittleThings\apache-maven-3.2.5，修改为自己的根目录。在环境变量Path后增加;%M2_HOME%\bin;。这样，就完成了配置。在命令行窗口输入mvn -version，能看到maven的基本信息，如maven home、java version等。​​ 修改settings.xml。settings.xml位于根目录/conf下。一般settings需要修改的有两处：本地仓库的位置和中央仓库的镜像。本地仓库一般默认安装在系统盘下，这样，新增的jar包都会下载安装到系统盘。为了避免这个，找到settings.xml中localRepository的注释，添加 lang: xml1&lt;localRepository&gt;D:/LittleThings/mvnrepo&lt;/localRepository&gt; 这里改成自己的本地仓库目录即可。一般由于众所周知的原因，很难从maven中央仓库下载下来jar包，因此，一般会添加镜像。 lang: xml12345678&lt;mirrors&gt; &lt;mirror&gt;&lt;id&gt;CN&lt;/id&gt; &lt;name&gt;OSChina Central&lt;/name&gt; &lt;url&gt;http://maven.oschina.net/content/groups/public/&lt;/url&gt; &lt;mirrorOf&gt;central&lt;/mirrorOf&gt; &lt;/mirror&gt; &lt;mirror&gt; &lt;id&gt;ibiblio.org&lt;/id&gt; &lt;name&gt;ibiblio Mirror of http://repo1.maven.org/maven2/&lt;/name&gt; &lt;url&gt;http://mirrors.ibiblio.org/pub/mirrors/maven2&lt;/url&gt; &lt;mirrorOf&gt;central&lt;/mirrorOf&gt; &lt;!-- United States, North Carolina --&gt; &lt;/mirror&gt; &lt;mirror&gt; &lt;id&gt;cica.es&lt;/id&gt; &lt;url&gt;http://ftp.cica.es/mirrors/maven2&lt;/url&gt; &lt;mirrorOf&gt;central&lt;/mirrorOf&gt; &lt;!-- Spain, Sevilla --&gt; &lt;/mirror&gt; &lt;mirror&gt; &lt;id&gt;maven.org&lt;/id&gt; &lt;url&gt;http://repo1.maven.org/maven2/&lt;/url&gt; &lt;mirrorOf&gt;central&lt;/mirrorOf&gt; &lt;/mirror&gt; &lt;mirror&gt; &lt;id&gt;jboss.com&lt;/id&gt; &lt;url&gt;http://repository.jboss.com/maven2/&lt;/url&gt; &lt;mirrorOf&gt;central&lt;/mirrorOf&gt; &lt;/mirror&gt; &lt;mirror&gt; &lt;id&gt;sonatype.org&lt;/id&gt; &lt;url&gt;http://repository.sonatype.org/content/groups/public/&lt;/url&gt; &lt;mirrorOf&gt;central&lt;/mirrorOf&gt; &lt;/mirror&gt; &lt;!-- mirror | Specifies a repository mirror site to use instead of a given repository. The repository that | this mirror serves has an ID that matches the mirrorOf element of this mirror. IDs are used | for inheritance and direct lookup purposes, and must be unique across the set of mirrors. | &lt;mirror&gt; &lt;id&gt;mirrorId&lt;/id&gt; &lt;mirrorOf&gt;repositoryId&lt;/mirrorOf&gt; &lt;name&gt;Human Readable Name for this Mirror.&lt;/name&gt; &lt;url&gt;http://my.repository.com/repo/path&lt;/url&gt; &lt;/mirror&gt; --&gt;&lt;/mirrors&gt; 至此，maven就初步安装完成可以使用了。]]></content>
      <categories>
        <category>maven</category>
      </categories>
      <tags>
        <tag>maven</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[热情、欣赏、诚实——头脑风暴成果演讲反思]]></title>
    <url>%2F2015%2F12%2F06%2F%E7%83%AD%E6%83%85%E6%AC%A3%E8%B5%8F%E8%AF%9A%E5%AE%9E%E5%A4%B4%E8%84%91%E9%A3%8E%E6%9A%B4%E6%88%90%E6%9E%9C%E6%BC%94%E8%AE%B2%E5%8F%8D%E6%80%9D%2F</url>
    <content type="text"><![CDATA[最近，Team Leader一直在搞头脑风暴，想要摩擦出火花，采集闪光的瞬间，集齐七个……嗯，就是想解放思想、实事求是。遂，每逢周三，组内汇聚一堂，坐而论道。 大头目：“TL，你们搞出啥子幺蛾子了吗？” TL：“我们展示一下呗！” 大头目：“好好好！搞搞搞！” 然后，这个锅我背了。小组分拨，我被分到了天灾。最后deadline到了，居然让我这个五号位划水辅助当carry。最后不负众望，嗝屁了。不过看到近卫的carry台风，很是欣赏，觉得需要学习一下，知耻而后勇嘛。 悲剧的开始作为一个高贵冷艳的程序员，在头脑风暴的时候就是各种划水，只因觉得这种会议太过务虚了。做出一个“惊艳”的产品？什么鬼，简直无法直视。也许是我太挑剔了，也许是我老了，我很少觉得什么东西我会用惊艳这个词去形容。大部分的时候，看到美女会欣赏，看到工具会判断是不是想要的，很少有那种非洲农业不发达看到金坷垃的感觉。而且，也使我想起了每天写文档写了N年还喜欢搞传销的某人。 大概就是这么反感了，失去了热情，最后自己都不信自己演讲时说的东西了。没有了热情，不相信自己写的东西，演说的时候就会无精打采，这也是演说失败的原因之一。 其实这样很不好，毕竟在team中，不管这个target对不对，得尽自己一份力。既然过于务虚，那就把它务实，这才是应有之义。 仓促的准备头脑风暴小组就这么分成了气宗和剑宗。气宗每天都在进行头脑风暴，还掏出了神器Mac Pro，使出了Keynote大法，还不停刺探我宗情报，并进行了一系列反间谍工作。然而我宗认为领导在对面，本身这个事情又是务虚，所有人都没有放在心上，组员都没有积极参与，无法进行有效的组织。最后，我只能临危受命，将组员最近在研究的一项技术进行介绍。毕竟这项技术和我们演讲的主题有着一定的关联。 此时，我们手里的材料只有这个未完成待验证的项目；我们知道的是气宗要使用酷炫的Keynote；气宗已经做了一周，而我们的准备时间是从现在起到明天下午开始演讲为止。WTF！没办法，只能想办法吹了。 正所谓知己知彼，百战不殆。敌方情报工作那么到位，想要与之一战，就只能从了解己方着手了。 跑了跑那个项目，果然是个未完成品，唯一拿得出手的只有概念——自动化测试了。此时的我已经开始质疑这个项目的重要性——我自己都不能说服自己，拿什么去说服别人呢？只能取巧，依靠一些技法了。 为了让展示不逊于Keynote，便求助于impress.js，使效果更加酷炫；同时开始计划讲稿，让听众忘记询问项目的不足和完成情况，专注于项目代表的意义。除此之外，最重要的是要我能相信这个项目。然而，我做不到，我不欣赏这个项目。 悲剧的演讲上台演讲时，确实成功地让听众惊艳于impress.js的效果，专注于项目的意义，从某种意义上来说，是成功的。然而由于我能明显感到和对手台风的巨大差距，这对我来说并不是一个成功的演讲。我并没有说服我自己去欣赏这个项目，所以演讲的时候我无法感动我自己，也无法感染听众。 痛定思痛，入手了《像TED一样演讲》。 于2015年8月阅毕。]]></content>
      <categories>
        <category>杂项</category>
      </categories>
      <tags>
        <tag>演讲</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[搭建简单jekyll小记]]></title>
    <url>%2F2015%2F12%2F06%2F%E6%90%AD%E5%BB%BA%E7%AE%80%E5%8D%95jekyll%E5%B0%8F%E8%AE%B0%2F</url>
    <content type="text"><![CDATA[简单来说，就是GitHub Pages + Jekyll + Sublime Text 3。 碰到的主要问题有 用Sublime Text 3来写Jekyll博客安装插件参考在mac上配置使用sublime-text-3来进行javascript开发。 然后安装Jekyll插件来使Sublime Text 3认识Jekyll。 文件名中文安装了插件后，可以参考这里来引入中文。示例如下：lang: liquid1&#123; % post_url 2015-12-06-在mac上配置使用sublime-text-3来进行javascript开发 %&#125;这里Jekyll使用的pygments不支持liquid，通过{和%之间加空格来显示代码。解决方法可参考这里。]]></content>
      <categories>
        <category>Jekyll</category>
      </categories>
      <tags>
        <tag>Jekyll</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[使用数据库自带的锁机制来处理竞争]]></title>
    <url>%2F2015%2F12%2F06%2F%E4%BD%BF%E7%94%A8%E6%95%B0%E6%8D%AE%E5%BA%93%E8%87%AA%E5%B8%A6%E7%9A%84%E9%94%81%E6%9C%BA%E5%88%B6%E6%9D%A5%E5%A4%84%E7%90%86%E7%AB%9E%E4%BA%89%2F</url>
    <content type="text"><![CDATA[2013年刚入职的时候，做的p2p项目，有这么个需求。 众所周知，p2p需要去投标，投标就会有竞争。比如阿猫和阿狗都看到一个项目只剩1份了，两个人同时投标。这时候系统就会判断阿猫买一份，余额刚好一份，可以买；在系统确定了这次购买订单，更新余额前，阿狗的请求也到了，系统还没更新余额，这时系统也让阿狗买了一份。这就导致实际上一份卖出了两份，这样并不好，会出现一系列问题，具体什么问题，出门右转找运营。 那么怎么办呢？就是经典的并发情况下锁机制的设计了。 当时负责我们p2p组的组长决定利用数据库的锁机制来处理，具体就是在数据库中增加一个字段key，通过对a的值的比对来保证投标的顺利进行。 lang: java1234567oldKey = getKey(); // 获取锁值processing(); // 处理if (checkKey()) &#123; // 检查锁没有变更则更新锁，否则回滚操作 updateKey();&#125; else &#123; rollback();&#125; 这样其实会有个问题，即在chenkKey()和updateKey()之间，会有可能有人也投标成功了。 怎么修改呢？其实很简单。我把chenkKey()和updateKey()合作一个方法checkAndUpdateKey()，直接在数据库中 lang: sql1update a set key = newKey where key = oldKey 这样代码逻辑就变成了 lang: java12345oldKey = getKey(); // 获取锁值processing(); // 处理if (!checkAndUpdateKey()) &#123; // 检查锁值变化并更新锁，失败则回滚操作 rollback();&#125; 搞定。 P.S.当然这样有个很大的问题，竞争多的时候很容易就投不中标。最好还是类似12306先把请求排队进入一个队列，然后再依次处理——比如一个先进先出队列。]]></content>
  </entry>
  <entry>
    <title><![CDATA[在Mac上配置使用git]]></title>
    <url>%2F2015%2F12%2F06%2F%E5%9C%A8mac%E4%B8%8A%E9%85%8D%E7%BD%AE%E4%BD%BF%E7%94%A8git%2F</url>
    <content type="text"><![CDATA[在 git下载Mac安装程序。 傻瓜安装git。 打开Terminal，输入git –version来检查。 下载 SourceTree。 傻瓜安装SourceTree并配置本地库和远程库。]]></content>
      <categories>
        <category>git</category>
      </categories>
      <tags>
        <tag>mac</tag>
        <tag>git</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[一些好用的小玩意]]></title>
    <url>%2F2015%2F12%2F06%2F%E4%B8%80%E4%BA%9B%E5%A5%BD%E7%94%A8%E7%9A%84%E5%B0%8F%E7%8E%A9%E6%84%8F%2F</url>
    <content type="text"><![CDATA[WindowsEverything整理目录确实是个好习惯，但人总有犯懒的时候。也有时候大概有那么个名字的文件，找不到放哪了。Everything通过索引纪录文件位置，支持模糊搜索，支持正则表达式。担心索引坏磁盘就当我没说。 MacSCROLL REVERSER非常好用的鼠标滚轮反转软件。有多少人像我一样触摸板喜欢上推页面看下一页但鼠标滚轮往下滑看下一页的？用SCROLL REVERSER，完美解决这个问题。 Alfred功能和Everything类似，增加了网络搜索功能。 Linux]]></content>
      <categories>
        <category>杂项</category>
      </categories>
      <tags>
        <tag>tool</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[PureJSOnePageScroll——JavaScript单页滚动插件]]></title>
    <url>%2F2015%2F12%2F06%2Fpurejsonepagescrolljavascript%E5%8D%95%E9%A1%B5%E6%BB%9A%E5%8A%A8%E6%8F%92%E4%BB%B6%2F</url>
    <content type="text"><![CDATA[啰嗦的背景最近有人问我像Coding.net啊这样的首页效果是不是很难。当然你让我从零开始弄一个确实很麻烦咯，不过这种肯定是有人做过了。于是找了找，便翻到了OnePageScroll。 最开始搜到的这个是基于JQuery的版本，在作者的仓库里还翻到了基于zepto的版本。不过我更喜欢不使用JQuery、Zepto等的更纯净的库，这就是本文介绍的PureJSOnePageScroll。点击查看特效 使用方式 引入文件lang: html12&lt;script type="text/javascript" src="onepagescroll.js"&gt;&lt;/script&gt;&lt;link href='onepage-scroll.css' rel='stylesheet' type='text/css'&gt; 当然你也可以通过require等来插入，贵客都会require了自然也不需要看这部分。 基本用法lang: html1234567891011121314151617&lt;body&gt; ... &lt;!-- main只是作为选择器用，语法是HTML5的document.querySelector，不会请百度 --&gt; &lt;div class="main"&gt; &lt;!-- section标签可以自定义 --&gt; &lt;section&gt;...&lt;/section&gt; &lt;section&gt;...&lt;/section&gt; ... &lt;/div&gt; ...&lt;/body&gt;&lt;script&gt; onePageScroll(".main", &#123; sectionContainer: "section", loop: true, responsiveFallback: false &#125;);&lt;/script&gt; 参数介绍lang: javascript1234567891011121314// 选择器，可以用class、id等onePageScroll(".main", &#123;// 标签名字，随意起，确保是页面容器，不与其它同名即可sectionContainer: "section",// CSS3动画效果，"ease", "linear", "ease-in", "ease-out", "ease-in-out",// 或者"cubic-bezier(0.175, 0.885, 0.420, 1.310)"easing: "ease",animationTime: 1000, // 动画时间pagination: true, // true显示分页，false隐藏分页updateURL: false, // 是否更新页面url锚beforeMove: function(index, next_el) &#123;&#125;, // 页面滚动前调用函数，编号从1开始，移动向第n页则index为nafterMove: function(index, next_el) &#123;&#125;, // 页面滚动后调用函数，移动到第n页index为nloop: false, // 是否可以从底部下移到顶部 keyboard: true, // 是否用键盘控制responsiveFallback: false // 滚动页面宽度小于定值时，宽度外使用浏览器自带滚动条 &#125;); 公共方法moveUp(“.main”); moveDown(“.main”); moveTo(“.main”, 3); // 这些没啥好解释的，上移、下移和移动到某页]]></content>
      <categories>
        <category>JavaScript</category>
      </categories>
      <tags>
        <tag>JavaScript</tag>
        <tag>PureJSOnePageScroll</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[JavaScript的AMD和CMD规范之我的看法]]></title>
    <url>%2F2015%2F12%2F06%2Fjavascript%E7%9A%84amd%E5%92%8Ccmd%E8%A7%84%E8%8C%83%E4%B9%8B%E6%88%91%E7%9A%84%E7%9C%8B%E6%B3%95%2F</url>
    <content type="text"><![CDATA[首先列出相关文献： AMD规范) CMD规范 AMD实现之RequireJS CMD实现之SeaJS 与RequireJS的异同 SeaJS与RequireJS最大的区别 AMD 的 CommonJS wrapping 时值双十一之后，贵宝又在忽悠NodeJS多么多么好，准备研究一下，便避不开这俩规范之争。 这俩规范的区别是对于这段代码（感谢Jerry Qu的代码） lang: javascript123456789101112131415161718192021222324252627282930313233//mod1.jsdefine(function() &#123; console.log('require module: mod1'); return &#123; hello: function() &#123; console.log("hello mod1"); &#125; &#125;;&#125;);//mod2.jsdefine(function() &#123; console.log('require module: mod2'); return &#123; hello: function() &#123; console.log("hello mod2"); &#125; &#125;;&#125;);//main.jsdefine(['mod1', 'mod2'], function(mod1, mod2) &#123; //运行至此，mod1.js 和 mod2.js 已经下载完成； //mod1、mod2 两个模块已经执行完，直接可用；console.log('require module: main');mod1.hello();mod2.hello();return &#123; hello: function() &#123; console.log('hello main'); &#125; &#125;; &#125;);&lt;!--index.html--&gt;&lt;script&gt; require(['main'], function(main) &#123; main.hello(); &#125;);&lt;/script&gt; 行为不一样。 在AMD规范下会先加载mod1、mod2、main（加载完成的时间顺序可能不一致），然后依次hello。 require module: mod1 require module: mod2 require module: main hello mod1 hello mod2 hello main在CMD规范下必须是谁要hello就加载对应和依赖的module。 require module: main require module: mod1 hello mod1 require module: mod2 hello mod2 hello main在各自的文中，都对问题说得很严重。在我看来，事实上，这个分歧主要还是一个着眼于服务器端，一个着眼于客户端（PC浏览器、移动浏览器、WebView等）。 在服务器端，最重要的事情之一是运维。在CMD这个框架下，代码的行为和作者的目的保持高度一致，同时还具备模块化的特性，自然是用CMD比较好。 在客户端，最重要的事情就是不要让用户等待。遵循AMD规范，将加载行为提前，可以保证客户端能更好地响应用户。 这两个环境下本来需求的优先级就不一致，为何非要某个规范一统前后台JavaScript开发？ 让上帝的归上帝，撒旦的归撒旦。]]></content>
      <categories>
        <category>JavaScript</category>
      </categories>
      <tags>
        <tag>JavaScript</tag>
        <tag>AMD</tag>
        <tag>CMD</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Maven使用记录（二）——在Eclipse中使用Maven来进行项目管理]]></title>
    <url>%2F2015%2F12%2F06%2FMaven%E4%BD%BF%E7%94%A8%E8%AE%B0%E5%BD%95%EF%BC%88%E4%BA%8C%EF%BC%89%E2%80%94%E2%80%94%E5%9C%A8Eclipse%E4%B8%AD%E4%BD%BF%E7%94%A8Maven%E6%9D%A5%E8%BF%9B%E8%A1%8C%E9%A1%B9%E7%9B%AE%E7%AE%A1%E7%90%86%2F</url>
    <content type="text"><![CDATA[在maven使用记录（一）-maven的安装和基础配置中下载和安装好maven后，使用Eclipse来对项目进行管理。默认使用了J2EE插件。如图。]]></content>
      <categories>
        <category>maven</category>
      </categories>
      <tags>
        <tag>maven</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[登长城记]]></title>
    <url>%2F2015%2F12%2F05%2F%E7%99%BB%E9%95%BF%E5%9F%8E%E8%AE%B0%2F</url>
    <content type="text"><![CDATA[十二月正是万物萧索，静心养气的时机。适逢朋友李来京培训，既然来京，便必择一日天气尚可之时，登那长城。 下了车，路边还有着未化的雪，和更换后的列车倒也相映成趣。大部分人都在八达岭站下了车，有看着像学生，有看着像留学生的，有看着像学生陪着家长的，三三两两出了站。站内看着人多，但毕竟淡季，出战就发现路上车很少，人也很少，一行人就沿着前几天游人踩出的痕迹前行。 不一会儿，我俩就到了长城脚下。虽然是入口，但不复暑假、国庆、亦或红叶时节的人潮，很容易就买到了票。没有那么多人，启动都快了许多，路也不是很陡，即便有点难度，也没有超出预期，感觉几分钟的时间，就翻过了两座敌楼。这时，开始的兴奋劲儿过去了，稍稍感觉到一丝酸。 北三楼前，路开始陡了起来。李瞅了瞅，对六十多度的坡表示惊悚，对古人的身体素质表示由衷的羡慕。“真的要继续爬吗？”李问。虽然不记得好汉石到底在哪了，我还是说：“走吧，原版的好汉石就在前边。”说完我便带头向前走去。 我一直认为在这类景区爬山，其实都是比较容易的。道都修好了，标识也很明显，只要埋头向前走，保持着节奏，就能走很远。唯一有些麻烦的地方就是如果人多的话，速度就会慢下来，节奏也不好保持，容易分神感觉到疲惫，就走不远了。 到了北四楼，李有些累，靠着墙休息。万幸的是路上虽陡，上周的降雪几本都化干净了，只有点点水渍。在城墙外有条路，尽头有几个人站在护栏里拍照，仿佛是以前到过的好汉石。“好像是原版好汉石，去看看吧。”李双手撑在膝上，咧着嘴说：“你去吧，是的话喊我。”我笑了笑，便往那块去了。果然是好汉石。然而不知为何，上面还有着残雪和冰。 好汉石上有不少游人合影。手扶着护栏，脚慢慢地在冰面少挪动。排队的人群，险峻的风景，更是平添了不少紧张感。李攀上去时正是逆光，真是如同词本身一般留影。 从好汉石开始，有不少游人直接返回了。大概是在这里留影已经完成任务，了结心愿。还有部分游人去了滑车。以前在别地玩过一回，速度很快，很有意思。李想着既然看了好汉石，已经可以回去了，只是没找见索道。我觉得既然来了，好歹也是要上北八楼看看，坐索道也要从最高的地方下去。于是我俩继续往前走。 大概是继续往上的人真的少了，路上可以看到未化开的冰，上边还覆盖着水渍，踩上去极容易滑。这些冰的位置也是十分奇怪。上周有雪，一般人在雪天爬长城，理应攀着护栏，靠两边行走才是，但冰基本集中在右侧护栏下，无声反驳了我的想当然。果然没有亲自来，就不知道他们是怎么做的了。 终于到了北八楼，游人意外很多。原来是冰雪未化，一边已经封路禁行，只剩下一条楼梯下去。楼梯很窄还有很厚一层冰，所以人们都堵在那儿了。我们便找了个地儿坐下歇歇。 这时节的长城，没有春季万物复苏的生气；没有夏季的郁郁葱葱；没有秋季漫山遍野的红叶；也没冬季的沁园春。这里有的是轻阳积雪，和枯黄的树木，以及被它们护卫着的点点青松。本来是一片萧条的景色，有了这些青松的存在，倒也别有一番趣味。有橙色的直升机在空中巡逻，大概是消防用的，感觉海拔比我们的位置还低一些。湛蓝的天上时不时有飞机爬升，留下两道不长的航迹云。在这个环境下闲聊，倒也是个不错的体验。 看看时间，差不多是返程的列车要到了，便下了长城。“可惜晚了点，去不成南楼。”李说。]]></content>
      <categories>
        <category>杂项</category>
      </categories>
      <tags>
        <tag>others</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[开始使用Jekyll]]></title>
    <url>%2F2015%2F12%2F04%2F%E5%BC%80%E5%A7%8B%E4%BD%BF%E7%94%A8jekyll%2F</url>
    <content type="text"><![CDATA[缘起主要是最近喜欢用Markdown，听说GitHub Pages能当主机用，还能挂域名，就换着试试。 原来用着WordPress每次写点东西都要折腾半天也是累不爱了。 就是试试Markdown随便写点，看看能不能用]]></content>
      <categories>
        <category>杂项</category>
      </categories>
      <tags>
        <tag>jekyll others</tag>
      </tags>
  </entry>
</search>
